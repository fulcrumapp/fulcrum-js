/* tslint:disable */
/* eslint-disable */
/**
 * rest-api
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 2
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from '../configuration.js';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from '../common.js';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, type RequestArgs, BaseAPI, RequiredError, operationServerMap } from '../base.js';
// @ts-ignore
import type { AddBatchOperationsRequest } from '../models/index.js';
// @ts-ignore
import type { AuthorizationsCreateRequest } from '../models/index.js';
// @ts-ignore
import type { AuthorizationsUpdateRequest } from '../models/index.js';
// @ts-ignore
import type { ChangesetsCreateRequest } from '../models/index.js';
// @ts-ignore
import type { ChangesetsUpdateRequest } from '../models/index.js';
// @ts-ignore
import type { ChoiceListsCreateRequest } from '../models/index.js';
// @ts-ignore
import type { ChoiceListsUpdateRequest } from '../models/index.js';
// @ts-ignore
import type { ClassificationSetsCreateRequest } from '../models/index.js';
// @ts-ignore
import type { ClassificationSetsUpdateRequest } from '../models/index.js';
// @ts-ignore
import type { CreateAttachment200Response } from '../models/index.js';
// @ts-ignore
import type { CreateAttachmentRequest } from '../models/index.js';
// @ts-ignore
import type { CreateBatchRequest } from '../models/index.js';
// @ts-ignore
import type { CreateGroup201Response } from '../models/index.js';
// @ts-ignore
import type { CreateGroupRequest } from '../models/index.js';
// @ts-ignore
import type { CreateMemberRequest } from '../models/index.js';
// @ts-ignore
import type { CreateReportTemplateRequest } from '../models/index.js';
// @ts-ignore
import type { CreateWorkflowRequest } from '../models/index.js';
// @ts-ignore
import type { DeleteMemberRequest } from '../models/index.js';
// @ts-ignore
import type { FinalizeAttachmentRequest } from '../models/index.js';
// @ts-ignore
import type { FormsCreateRequest } from '../models/index.js';
// @ts-ignore
import type { FormsUpdateRequest } from '../models/index.js';
// @ts-ignore
import type { GetAllAttachments200Response } from '../models/index.js';
// @ts-ignore
import type { GetAllAttachments401Response } from '../models/index.js';
// @ts-ignore
import type { GetSingleAttachment200Response } from '../models/index.js';
// @ts-ignore
import type { LayersCreateRequest } from '../models/index.js';
// @ts-ignore
import type { LayersUpdateRequest } from '../models/index.js';
// @ts-ignore
import type { MembershipsChangePermissionsRequest } from '../models/index.js';
// @ts-ignore
import type { ModelRecord } from '../models/index.js';
// @ts-ignore
import type { ProjectsCreateRequest } from '../models/index.js';
// @ts-ignore
import type { ProjectsUpdateRequest } from '../models/index.js';
// @ts-ignore
import type { QueryPostRequest } from '../models/index.js';
// @ts-ignore
import type { RecordsCreateRequest } from '../models/index.js';
// @ts-ignore
import type { RecordsGetAll400Response } from '../models/index.js';
// @ts-ignore
import type { RecordsResponse } from '../models/index.js';
// @ts-ignore
import type { RecordsUpdateRequest } from '../models/index.js';
// @ts-ignore
import type { UpdateGroupNameDescriptionRequest } from '../models/index.js';
// @ts-ignore
import type { UpdateGroupPermissionsRequest } from '../models/index.js';
// @ts-ignore
import type { UpdateMemberRequest } from '../models/index.js';
// @ts-ignore
import type { UpdateReportTemplateRequest } from '../models/index.js';
// @ts-ignore
import type { UpdateWorkflowRequest } from '../models/index.js';
// @ts-ignore
import type { WebhooksCreate201Response } from '../models/index.js';
// @ts-ignore
import type { WebhooksCreate422Response } from '../models/index.js';
// @ts-ignore
import type { WebhooksCreateRequest } from '../models/index.js';
// @ts-ignore
import type { WebhooksGetAll200Response } from '../models/index.js';
// @ts-ignore
import type { WebhooksUpdateRequest } from '../models/index.js';
/**
 * DefaultApi - axios parameter creator
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Using the batch operations API, you can bulk delete records from a form or update project, assignee, or status values on multiple records.
         * @summary Add batch operations
         * @param {string} batchId ID of the batch
         * @param {AddBatchOperationsRequest} [addBatchOperationsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addBatchOperations: async (batchId: string, addBatchOperationsRequest?: AddBatchOperationsRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'batchId' is not null or undefined
            assertParamExists('addBatchOperations', 'batchId', batchId)
            const localVarPath = `/v2/batch/{batch_id}/operations.json`
                .replace(`{${"batch_id"}}`, encodeURIComponent(String(batchId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "X-ApiToken", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addBatchOperationsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get All Audio
         * @param {string} [recordId] The ID of the record with which the video is associated.
         * @param {string} [formId] The ID of the form with which the video is associated. Leaving this blank will query against all of your videos.
         * @param {boolean} [newestFirst] If present, videos will be sorted by updated_at date.
         * @param {boolean} [processed] Video has been completely processed.
         * @param {boolean} [stored] Video has been completely stored.
         * @param {boolean} [uploaded] Video has been completely uploaded.
         * @param {number} [page] The page number requested
         * @param {number} [perPage] Number of items per page
         * @param {string} [accept] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        audioGetAll: async (recordId?: string, formId?: string, newestFirst?: boolean, processed?: boolean, stored?: boolean, uploaded?: boolean, page?: number, perPage?: number, accept?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/audio.json`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "X-ApiToken", configuration)

            if (recordId !== undefined) {
                localVarQueryParameter['record_id'] = recordId;
            }

            if (formId !== undefined) {
                localVarQueryParameter['form_id'] = formId;
            }

            if (newestFirst !== undefined) {
                localVarQueryParameter['newest_first'] = newestFirst;
            }

            if (processed !== undefined) {
                localVarQueryParameter['processed'] = processed;
            }

            if (stored !== undefined) {
                localVarQueryParameter['stored'] = stored;
            }

            if (uploaded !== undefined) {
                localVarQueryParameter['uploaded'] = uploaded;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }


    
            if (accept != null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get GeoJSON Tracks for All Audio
         * @param {string} [accept] 
         * @param {string} [type] Set value to &#x60;points&#x60; to fetch tracks as GeoJSON points
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        audioGetAllTracksGeojson: async (accept?: string, type?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/audio/tracks.geojson`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "X-ApiToken", configuration)

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }


    
            if (accept != null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get GPX Tracks for All Audio
         * @param {string} [accept] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        audioGetAllTracksGpx: async (accept?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/audio/tracks.gpx`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "X-ApiToken", configuration)


    
            if (accept != null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get JSON Tracks for All Audio
         * @param {string} [accept] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        audioGetAllTracksJson: async (accept?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/audio/tracks.json`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "X-ApiToken", configuration)


    
            if (accept != null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get KML Tracks for All Audio
         * @param {string} [accept] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        audioGetAllTracksKml: async (accept?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/audio/tracks.kml`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "X-ApiToken", configuration)


    
            if (accept != null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Original Audio File
         * @param {string} audioId Audio ID
         * @param {string} [accept] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        audioGetOriginalFile: async (audioId: string, accept?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'audioId' is not null or undefined
            assertParamExists('audioGetOriginalFile', 'audioId', audioId)
            const localVarPath = `/v2/audio/{audio_id}.mp4`
                .replace(`{${"audio_id"}}`, encodeURIComponent(String(audioId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "X-ApiToken", configuration)


    
            if (accept != null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Audio Metadata
         * @param {string} audioId Audio ID
         * @param {string} [accept] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        audioGetSingleMetadata: async (audioId: string, accept?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'audioId' is not null or undefined
            assertParamExists('audioGetSingleMetadata', 'audioId', audioId)
            const localVarPath = `/v2/audio/{audio_id}.json`
                .replace(`{${"audio_id"}}`, encodeURIComponent(String(audioId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "X-ApiToken", configuration)


    
            if (accept != null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get GeoJSON Audio Track
         * @param {string} audioId Audio ID
         * @param {string} [accept] 
         * @param {string} [type] Set value to &#x60;points&#x60; to fetch tracks as GeoJSON points
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        audioGetSingleTrackGeojson: async (audioId: string, accept?: string, type?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'audioId' is not null or undefined
            assertParamExists('audioGetSingleTrackGeojson', 'audioId', audioId)
            const localVarPath = `/v2/audio/{audio_id}/track.geojson`
                .replace(`{${"audio_id"}}`, encodeURIComponent(String(audioId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "X-ApiToken", configuration)

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }


    
            if (accept != null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get GPX Audio Track
         * @param {string} audioId Audio ID
         * @param {string} [accept] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        audioGetSingleTrackGpx: async (audioId: string, accept?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'audioId' is not null or undefined
            assertParamExists('audioGetSingleTrackGpx', 'audioId', audioId)
            const localVarPath = `/v2/audio/{audio_id}/track.gpx`
                .replace(`{${"audio_id"}}`, encodeURIComponent(String(audioId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "X-ApiToken", configuration)


    
            if (accept != null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get JSON Audio Track
         * @param {string} audioId Audio ID
         * @param {string} [accept] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        audioGetSingleTrackJson: async (audioId: string, accept?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'audioId' is not null or undefined
            assertParamExists('audioGetSingleTrackJson', 'audioId', audioId)
            const localVarPath = `/v2/audio/{audio_id}/track.json`
                .replace(`{${"audio_id"}}`, encodeURIComponent(String(audioId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "X-ApiToken", configuration)


    
            if (accept != null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get KML Audio Track
         * @param {string} audioId Audio ID
         * @param {string} [accept] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        audioGetSingleTrackKml: async (audioId: string, accept?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'audioId' is not null or undefined
            assertParamExists('audioGetSingleTrackKml', 'audioId', audioId)
            const localVarPath = `/v2/audio/{audio_id}/track.kml`
                .replace(`{${"audio_id"}}`, encodeURIComponent(String(audioId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "X-ApiToken", configuration)


    
            if (accept != null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Upload audio with optional track file
         * @summary Upload Audio
         * @param {string} [accept] 
         * @param {string} [contentType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        audioUpload: async (accept?: string, contentType?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/audio/upload.json`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "X-ApiToken", configuration)


    
            if (accept != null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get All Audit Logs
         * @param {string} [source] Valid options include: &#x60;export&#x60;, &#x60;data_export&#x60;, &#x60;membership&#x60;, &#x60;layer&#x60;, &#x60;project&#x60;, &#x60;audit_log&#x60;, &#x60;role&#x60;, &#x60;form&#x60;, &#x60;data_share&#x60;, &#x60;classification_set&#x60;, &#x60;authorization&#x60;, &#x60;choice_list&#x60;, &#x60;import&#x60;, &#x60;organization&#x60;, &#x60;workflow&#x60;, &#x60;webhook&#x60;
         * @param {string} [activity] The available actions vary by log type but a complete list of valid actions includes: &#x60;update&#x60;, &#x60;create&#x60;, &#x60;permission_update&#x60;, &#x60;download&#x60;, &#x60;delete&#x60;, &#x60;reset&#x60;, &#x60;share_enabled&#x60;, &#x60;share_disabled&#x60;, &#x60;update_credit_card&#x60;, &#x60;plan_change&#x60;, &#x60;billing_emails_change&#x60;, &#x60;update_storage&#x60;, &#x60;add_credit&#x60;, &#x60;change_default&#x60;.
         * @param {string} [ip] Filter by ip address of the of the audit log action. The ip address must be an exact match in order to return in values from this filter.
         * @param {string} [user] Filter by user responsible for the logged changes. This parameter must be the Fulcrum resource id for the user in question, which can be obtained from the membership API.
         * @param {string} [updatedSince] Returns log entries since the given unix timestamp.
         * @param {string} [updatedBefore] Returns log entries before the given unix timestamp.
         * @param {number} [page] The page number requested
         * @param {number} [perPage] Number of items per page
         * @param {string} [accept] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        auditLogsGetAll: async (source?: string, activity?: string, ip?: string, user?: string, updatedSince?: string, updatedBefore?: string, page?: number, perPage?: number, accept?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/audit_logs.json`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "X-ApiToken", configuration)

            if (source !== undefined) {
                localVarQueryParameter['source'] = source;
            }

            if (activity !== undefined) {
                localVarQueryParameter['activity'] = activity;
            }

            if (ip !== undefined) {
                localVarQueryParameter['ip'] = ip;
            }

            if (user !== undefined) {
                localVarQueryParameter['user'] = user;
            }

            if (updatedSince !== undefined) {
                localVarQueryParameter['updated_since'] = (updatedSince as any instanceof Date) ?
                    (updatedSince as any).toISOString() :
                    updatedSince;
            }

            if (updatedBefore !== undefined) {
                localVarQueryParameter['updated_before'] = (updatedBefore as any instanceof Date) ?
                    (updatedBefore as any).toISOString() :
                    updatedBefore;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }


    
            if (accept != null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Single Audit Log
         * @param {string} auditLogId Audit Log ID
         * @param {string} [accept] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        auditLogsGetSingle: async (auditLogId: string, accept?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'auditLogId' is not null or undefined
            assertParamExists('auditLogsGetSingle', 'auditLogId', auditLogId)
            const localVarPath = `/v2/audit_logs/{audit_log_id}.json`
                .replace(`{${"audit_log_id"}}`, encodeURIComponent(String(auditLogId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "X-ApiToken", configuration)


    
            if (accept != null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create Authorization
         * @param {string} [accept] 
         * @param {string} [contentType] 
         * @param {AuthorizationsCreateRequest} [authorizationsCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authorizationsCreate: async (accept?: string, contentType?: string, authorizationsCreateRequest?: AuthorizationsCreateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/authorizations.json`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "X-ApiToken", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (accept != null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(authorizationsCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Authorization
         * @param {string} authorizationId Authorization ID
         * @param {string} [accept] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authorizationsDelete: async (authorizationId: string, accept?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorizationId' is not null or undefined
            assertParamExists('authorizationsDelete', 'authorizationId', authorizationId)
            const localVarPath = `/v2/authorizations/{authorization_id}.json`
                .replace(`{${"authorization_id"}}`, encodeURIComponent(String(authorizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "X-ApiToken", configuration)


    
            if (accept != null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get All Authorizations
         * @param {number} [page] The page number requested
         * @param {number} [perPage] Number of items per page
         * @param {string} [accept] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authorizationsGetAll: async (page?: number, perPage?: number, accept?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/authorizations.json`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "X-ApiToken", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }


    
            if (accept != null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Single Authorization
         * @param {string} authorizationId Authorization ID
         * @param {string} [accept] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authorizationsGetSingle: async (authorizationId: string, accept?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorizationId' is not null or undefined
            assertParamExists('authorizationsGetSingle', 'authorizationId', authorizationId)
            const localVarPath = `/v2/authorizations/{authorization_id}.json`
                .replace(`{${"authorization_id"}}`, encodeURIComponent(String(authorizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "X-ApiToken", configuration)


    
            if (accept != null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Authorization
         * @param {string} authorizationId Authorization ID
         * @param {string} [accept] 
         * @param {string} [contentType] 
         * @param {AuthorizationsUpdateRequest} [authorizationsUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authorizationsUpdate: async (authorizationId: string, accept?: string, contentType?: string, authorizationsUpdateRequest?: AuthorizationsUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorizationId' is not null or undefined
            assertParamExists('authorizationsUpdate', 'authorizationId', authorizationId)
            const localVarPath = `/v2/authorizations/{authorization_id}.json`
                .replace(`{${"authorization_id"}}`, encodeURIComponent(String(authorizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "X-ApiToken", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (accept != null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(authorizationsUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Close Changeset
         * @param {string} changesetId Changeset ID
         * @param {string} [accept] 
         * @param {string} [contentType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changesetsClose: async (changesetId: string, accept?: string, contentType?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'changesetId' is not null or undefined
            assertParamExists('changesetsClose', 'changesetId', changesetId)
            const localVarPath = `/v2/changesets/{changeset_id}/close.json`
                .replace(`{${"changeset_id"}}`, encodeURIComponent(String(changesetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "X-ApiToken", configuration)


    
            if (accept != null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create Changeset
         * @param {string} [accept] 
         * @param {string} [contentType] 
         * @param {ChangesetsCreateRequest} [changesetsCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changesetsCreate: async (accept?: string, contentType?: string, changesetsCreateRequest?: ChangesetsCreateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/changesets.json`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "X-ApiToken", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (accept != null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(changesetsCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get All Changesets
         * @param {number} [page] The page number requested
         * @param {number} [perPage] Number of items per page
         * @param {string} [accept] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changesetsGetAll: async (page?: number, perPage?: number, accept?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/changesets.json`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "X-ApiToken", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }


    
            if (accept != null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Single Changeset
         * @param {string} changesetId Changeset ID
         * @param {string} [accept] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changesetsGetSingle: async (changesetId: string, accept?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'changesetId' is not null or undefined
            assertParamExists('changesetsGetSingle', 'changesetId', changesetId)
            const localVarPath = `/v2/changesets/{changeset_id}.json`
                .replace(`{${"changeset_id"}}`, encodeURIComponent(String(changesetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "X-ApiToken", configuration)


    
            if (accept != null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Changeset
         * @param {string} changesetId Changeset ID
         * @param {string} [accept] 
         * @param {string} [contentType] 
         * @param {ChangesetsUpdateRequest} [changesetsUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changesetsUpdate: async (changesetId: string, accept?: string, contentType?: string, changesetsUpdateRequest?: ChangesetsUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'changesetId' is not null or undefined
            assertParamExists('changesetsUpdate', 'changesetId', changesetId)
            const localVarPath = `/v2/changesets/{changeset_id}.json`
                .replace(`{${"changeset_id"}}`, encodeURIComponent(String(changesetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "X-ApiToken", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (accept != null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(changesetsUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create Choice List
         * @param {string} [accept] 
         * @param {string} [contentType] 
         * @param {ChoiceListsCreateRequest} [choiceListsCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        choiceListsCreate: async (accept?: string, contentType?: string, choiceListsCreateRequest?: ChoiceListsCreateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/choice_lists.json`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "X-ApiToken", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (accept != null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(choiceListsCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Choice List
         * @param {string} choiceListId Choice List ID
         * @param {string} [accept] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        choiceListsDelete: async (choiceListId: string, accept?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'choiceListId' is not null or undefined
            assertParamExists('choiceListsDelete', 'choiceListId', choiceListId)
            const localVarPath = `/v2/choice_lists/{choice_list_id}.json`
                .replace(`{${"choice_list_id"}}`, encodeURIComponent(String(choiceListId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "X-ApiToken", configuration)


    
            if (accept != null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get All Choice Lists
         * @param {number} [page] The page number requested
         * @param {number} [perPage] Number of items per page
         * @param {string} [accept] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        choiceListsGetAll: async (page?: number, perPage?: number, accept?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/choice_lists.json`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "X-ApiToken", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }


    
            if (accept != null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Single Choice List
         * @param {string} choiceListId Choice List ID
         * @param {string} [accept] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        choiceListsGetSingle: async (choiceListId: string, accept?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'choiceListId' is not null or undefined
            assertParamExists('choiceListsGetSingle', 'choiceListId', choiceListId)
            const localVarPath = `/v2/choice_lists/{choice_list_id}.json`
                .replace(`{${"choice_list_id"}}`, encodeURIComponent(String(choiceListId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "X-ApiToken", configuration)


    
            if (accept != null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Choice List
         * @param {string} choiceListId Choice List ID
         * @param {string} [accept] 
         * @param {string} [contentType] 
         * @param {ChoiceListsUpdateRequest} [choiceListsUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        choiceListsUpdate: async (choiceListId: string, accept?: string, contentType?: string, choiceListsUpdateRequest?: ChoiceListsUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'choiceListId' is not null or undefined
            assertParamExists('choiceListsUpdate', 'choiceListId', choiceListId)
            const localVarPath = `/v2/choice_lists/{choice_list_id}.json`
                .replace(`{${"choice_list_id"}}`, encodeURIComponent(String(choiceListId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "X-ApiToken", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (accept != null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(choiceListsUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create Classification Set
         * @param {string} [accept] 
         * @param {string} [contentType] 
         * @param {ClassificationSetsCreateRequest} [classificationSetsCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        classificationSetsCreate: async (accept?: string, contentType?: string, classificationSetsCreateRequest?: ClassificationSetsCreateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/classification_sets.json`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "X-ApiToken", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (accept != null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(classificationSetsCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Classification Set
         * @param {string} classificationSetId Classification Set ID
         * @param {string} [accept] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        classificationSetsDelete: async (classificationSetId: string, accept?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'classificationSetId' is not null or undefined
            assertParamExists('classificationSetsDelete', 'classificationSetId', classificationSetId)
            const localVarPath = `/v2/classification_sets/{classification_set_id}.json`
                .replace(`{${"classification_set_id"}}`, encodeURIComponent(String(classificationSetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "X-ApiToken", configuration)


    
            if (accept != null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get All Classification Sets
         * @param {number} [page] The page number requested
         * @param {number} [perPage] Number of items per page
         * @param {string} [accept] 
         * @param {ClassificationSetsGetAllTypeEnum} [type] Type of classification sets to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        classificationSetsGetAll: async (page?: number, perPage?: number, accept?: string, type?: ClassificationSetsGetAllTypeEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/classification_sets.json`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "X-ApiToken", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }


    
            if (accept != null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Single Classification Set
         * @param {string} classificationSetId Classification Set ID
         * @param {string} [accept] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        classificationSetsGetSingle: async (classificationSetId: string, accept?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'classificationSetId' is not null or undefined
            assertParamExists('classificationSetsGetSingle', 'classificationSetId', classificationSetId)
            const localVarPath = `/v2/classification_sets/{classification_set_id}.json`
                .replace(`{${"classification_set_id"}}`, encodeURIComponent(String(classificationSetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "X-ApiToken", configuration)


    
            if (accept != null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Classification Set
         * @param {string} classificationSetId Classification Set ID
         * @param {string} [accept] 
         * @param {string} [contentType] 
         * @param {ClassificationSetsUpdateRequest} [classificationSetsUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        classificationSetsUpdate: async (classificationSetId: string, accept?: string, contentType?: string, classificationSetsUpdateRequest?: ClassificationSetsUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'classificationSetId' is not null or undefined
            assertParamExists('classificationSetsUpdate', 'classificationSetId', classificationSetId)
            const localVarPath = `/v2/classification_sets/{classification_set_id}.json`
                .replace(`{${"classification_set_id"}}`, encodeURIComponent(String(classificationSetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "X-ApiToken", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (accept != null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(classificationSetsUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * There is only one parameter that is required for creating an attachment: `owners`. You must specify at least one owner of type `record` or `form`. If you create a `record` attachment you can optionally include a `name` and `file_size`. The name will be the name of the file shown in the record information. The file_size is only used for verifying that uploading this attachment will not exceed your current storage limit. If no file_size is provided the attachment may be rejected once it has been uploaded. The response will provide the `url` to upload (PUT) the file to.
         * @summary Create Attachment
         * @param {string} [xApitoken] API Token. Required to authenticate the request.
         * @param {CreateAttachmentRequest} [createAttachmentRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAttachment: async (xApitoken?: string, createAttachmentRequest?: CreateAttachmentRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/attachments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "X-ApiToken", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (xApitoken != null) {
                localVarHeaderParameter['x-apitoken'] = String(xApitoken);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createAttachmentRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Using the batch operations API, you can bulk delete records from a form.
         * @summary Create Batch to Bulk Delete Records
         * @param {CreateBatchRequest} [createBatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBatch: async (createBatchRequest?: CreateBatchRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/batch.json`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "X-ApiToken", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createBatchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create Group
         * @param {string} [accept] 
         * @param {string} [contentType] 
         * @param {CreateGroupRequest} [createGroupRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGroup: async (accept?: string, contentType?: string, createGroupRequest?: CreateGroupRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/groups.json`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "X-ApiToken", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (accept != null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createGroupRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create Member
         * @param {string} [accept] 
         * @param {string} [contentType] 
         * @param {CreateMemberRequest} [createMemberRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMember: async (accept?: string, contentType?: string, createMemberRequest?: CreateMemberRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/memberships.json`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "X-ApiToken", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (accept != null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createMemberRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create Report Template
         * @param {CreateReportTemplateRequest} [createReportTemplateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createReportTemplate: async (createReportTemplateRequest?: CreateReportTemplateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/report_templates.json`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "X-ApiToken", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createReportTemplateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create Workflow
         * @param {string} [accept] 
         * @param {string} [contentTyoe] 
         * @param {CreateWorkflowRequest} [createWorkflowRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWorkflow: async (accept?: string, contentTyoe?: string, createWorkflowRequest?: CreateWorkflowRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/workflows.json`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "X-ApiToken", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (accept != null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }
            if (contentTyoe != null) {
                localVarHeaderParameter['Content-Tyoe'] = String(contentTyoe);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createWorkflowRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The delete endpoint only applies to Form attachments. Use this endpoint to delete an attachment. For record attachments, simply remove the association of an attachment from the record and the attachment will be deleted.
         * @summary Delete Attachment
         * @param {string} attachmentId The attachment\&#39;s ID
         * @param {string} [xApitoken] API Token. Required to authenticate the request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAttachment: async (attachmentId: string, xApitoken?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'attachmentId' is not null or undefined
            assertParamExists('deleteAttachment', 'attachmentId', attachmentId)
            const localVarPath = `/v2/attachments/{attachment_id}`
                .replace(`{${"attachment_id"}}`, encodeURIComponent(String(attachmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "X-ApiToken", configuration)


    
            if (xApitoken != null) {
                localVarHeaderParameter['x-apitoken'] = String(xApitoken);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Group
         * @param {string} groupId ID of the group
         * @param {string} [accept] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGroup: async (groupId: string, accept?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('deleteGroup', 'groupId', groupId)
            const localVarPath = `/v2/groups/{group_id}.json`
                .replace(`{${"group_id"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "X-ApiToken", configuration)


    
            if (accept != null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Member
         * @param {string} membershipId The ID of the member
         * @param {DeleteMemberRequest} [deleteMemberRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMember: async (membershipId: string, deleteMemberRequest?: DeleteMemberRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'membershipId' is not null or undefined
            assertParamExists('deleteMember', 'membershipId', membershipId)
            const localVarPath = `/v2/memberships/{membership_id}.json`
                .replace(`{${"membership_id"}}`, encodeURIComponent(String(membershipId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "X-ApiToken", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deleteMemberRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Report Template
         * @param {string} id The id of the report
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteReportTemplate: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteReportTemplate', 'id', id)
            const localVarPath = `/v2/report_templates/{id}.json`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "X-ApiToken", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Workflow
         * @param {string} workflowId The ID of the workflow
         * @param {string} [accept] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWorkflow: async (workflowId: string, accept?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workflowId' is not null or undefined
            assertParamExists('deleteWorkflow', 'workflowId', workflowId)
            const localVarPath = `/v2/workflows/{workflow_id}.json`
                .replace(`{${"workflow_id"}}`, encodeURIComponent(String(workflowId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "X-ApiToken", configuration)


    
            if (accept != null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The finalize endpoint is a required step for Form attachments. Use this endpoint to tell Fulcrum that your attachment has been uploaded.
         * @summary Finalize Attachment
         * @param {string} [xApitoken] API Token. Required to authenticate the request.
         * @param {FinalizeAttachmentRequest} [finalizeAttachmentRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        finalizeAttachment: async (xApitoken?: string, finalizeAttachmentRequest?: FinalizeAttachmentRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/attachments/finalize`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "X-ApiToken", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (xApitoken != null) {
                localVarHeaderParameter['x-apitoken'] = String(xApitoken);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(finalizeAttachmentRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create Form
         * @param {string} [accept] 
         * @param {string} [contentType] 
         * @param {FormsCreateRequest} [formsCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        formsCreate: async (accept?: string, contentType?: string, formsCreateRequest?: FormsCreateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/forms.json`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "X-ApiToken", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (accept != null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(formsCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Form
         * @param {string} formId Form ID
         * @param {string} [accept] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        formsDelete: async (formId: string, accept?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'formId' is not null or undefined
            assertParamExists('formsDelete', 'formId', formId)
            const localVarPath = `/v2/forms/{form_id}.json`
                .replace(`{${"form_id"}}`, encodeURIComponent(String(formId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "X-ApiToken", configuration)


    
            if (accept != null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get All Forms
         * @param {boolean} [schema] schema&#x3D;false will only return the form metadata
         * @param {number} [page] The page number requested
         * @param {number} [perPage] Number of items per page
         * @param {string} [accept] 
         * @param {FormsGetAllTypeEnum} [type] Types of forms to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        formsGetAll: async (schema?: boolean, page?: number, perPage?: number, accept?: string, type?: FormsGetAllTypeEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/forms.json`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "X-ApiToken", configuration)

            if (schema !== undefined) {
                localVarQueryParameter['schema'] = schema;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }


    
            if (accept != null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Form History
         * @param {string} formId Form ID
         * @param {number} [version] The form history version
         * @param {number} [page] The page number requested
         * @param {number} [perPage] Number of items per page
         * @param {string} [accept] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        formsGetHistory: async (formId: string, version?: number, page?: number, perPage?: number, accept?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'formId' is not null or undefined
            assertParamExists('formsGetHistory', 'formId', formId)
            const localVarPath = `/v2/forms/{form_id}/history.json`
                .replace(`{${"form_id"}}`, encodeURIComponent(String(formId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "X-ApiToken", configuration)

            if (version !== undefined) {
                localVarQueryParameter['version'] = version;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }


    
            if (accept != null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Single Form
         * @param {string} formId Form ID
         * @param {string} [accept] 
         * @param {boolean} [schema] schema&#x3D;false will only return the form metadata
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        formsGetSingle: async (formId: string, accept?: string, schema?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'formId' is not null or undefined
            assertParamExists('formsGetSingle', 'formId', formId)
            const localVarPath = `/v2/forms/{form_id}.json`
                .replace(`{${"form_id"}}`, encodeURIComponent(String(formId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "X-ApiToken", configuration)

            if (schema !== undefined) {
                localVarQueryParameter['schema'] = schema;
            }


    
            if (accept != null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Form
         * @param {string} formId Form ID
         * @param {string} [accept] 
         * @param {string} [contentType] 
         * @param {FormsUpdateRequest} [formsUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        formsUpdate: async (formId: string, accept?: string, contentType?: string, formsUpdateRequest?: FormsUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'formId' is not null or undefined
            assertParamExists('formsUpdate', 'formId', formId)
            const localVarPath = `/v2/forms/{form_id}.json`
                .replace(`{${"form_id"}}`, encodeURIComponent(String(formId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "X-ApiToken", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (accept != null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(formsUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get All Attachments
         * @param {string} [recordId] The ID of the record with which the attachment is associated. This is required when listing record attachments.
         * @param {string} [formId] The ID of the form with which the attachment is associated. This parameter will allow you to get all reference files within a form, NOT all of the record attachments in a form
         * @param {string} [ownerType] The type of attachment to query for. Must be either &#x60;form&#x60; or &#x60;record&#x60;.
         * @param {string} [xApitoken] API Token. Required to authenticate the request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllAttachments: async (recordId?: string, formId?: string, ownerType?: string, xApitoken?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/attachments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "X-ApiToken", configuration)

            if (recordId !== undefined) {
                localVarQueryParameter['record_id'] = recordId;
            }

            if (formId !== undefined) {
                localVarQueryParameter['form_id'] = formId;
            }

            if (ownerType !== undefined) {
                localVarQueryParameter['owner_type'] = ownerType;
            }


    
            if (xApitoken != null) {
                localVarHeaderParameter['x-apitoken'] = String(xApitoken);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get All Batches
         * @param {string} [page] 
         * @param {string} [perPage] 
         * @param {string} [sort] 
         * @param {string} [sortDirection] One of DESC for descending or ASC for ascending
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllBatches: async (page?: string, perPage?: string, sort?: string, sortDirection?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/batch.json`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "X-ApiToken", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (sortDirection !== undefined) {
                localVarQueryParameter['sort_direction'] = sortDirection;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get All Groups
         * @param {string} [page] 
         * @param {string} [perPage] 
         * @param {boolean} [associations] Set to &#x60;true&#x60; in order to see each group\&#39;s assigned &#x60;member_ids&#x60;, &#x60;layer_ids&#x60;, &#x60;project_ids&#x60; and &#x60;form_ids&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllGroups: async (page?: string, perPage?: string, associations?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/groups.json`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "X-ApiToken", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (associations !== undefined) {
                localVarQueryParameter['associations'] = associations;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Membership Permissions
         * @param {string} type The type of permission (member_forms, member_layers, member_projects, form_members, layer_members, or project_members)
         * @param {string} objectId The membership_id of the user or the id of the form, layer or project
         * @param {number} [page] The page number requested
         * @param {number} [perPage] Number of items per page
         * @param {string} [accept] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllMemberships: async (type: string, objectId: string, page?: number, perPage?: number, accept?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'type' is not null or undefined
            assertParamExists('getAllMemberships', 'type', type)
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('getAllMemberships', 'objectId', objectId)
            const localVarPath = `/v2/permissions.json`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "X-ApiToken", configuration)

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (objectId !== undefined) {
                localVarQueryParameter['object_id'] = objectId;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }


    
            if (accept != null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get All Report Templates
         * @param {number} [page] The page number requested
         * @param {number} [perPage] Number of items per page
         * @param {string} [formId] The form to fetch reports for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllReportTemplates: async (page?: number, perPage?: number, formId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/report_templates.json`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "X-ApiToken", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (formId !== undefined) {
                localVarQueryParameter['form_id'] = formId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get All Workflows
         * @param {number} [page] The page number requested
         * @param {number} [perPage] Number of items per page
         * @param {string} [accept] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllWorkflows: async (page?: number, perPage?: number, accept?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/workflows.json`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "X-ApiToken", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }


    
            if (accept != null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Group Resource
         * @param {string} groupId Group ID
         * @param {string} resource One of &#x60;members&#x60;, &#x60;projects&#x60;, &#x60;layers&#x60; or &#x60;forms&#x60;
         * @param {string} [accept] 
         * @param {number} [page] Page of the response
         * @param {number} [perPage] Amount of items in every page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupResource: async (groupId: string, resource: string, accept?: string, page?: number, perPage?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('getGroupResource', 'groupId', groupId)
            // verify required parameter 'resource' is not null or undefined
            assertParamExists('getGroupResource', 'resource', resource)
            const localVarPath = `/v2/groups/{group_id}/{resource}.json`
                .replace(`{${"group_id"}}`, encodeURIComponent(String(groupId)))
                .replace(`{${"resource"}}`, encodeURIComponent(String(resource)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "X-ApiToken", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }


    
            if (accept != null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Single Attachment
         * @param {string} attachmentId The attachment id.
         * @param {string} [xApitoken] API Token. Required to authenticate the request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSingleAttachment: async (attachmentId: string, xApitoken?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'attachmentId' is not null or undefined
            assertParamExists('getSingleAttachment', 'attachmentId', attachmentId)
            const localVarPath = `/v2/attachments/{attachment_id}`
                .replace(`{${"attachment_id"}}`, encodeURIComponent(String(attachmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "X-ApiToken", configuration)


    
            if (xApitoken != null) {
                localVarHeaderParameter['x-apitoken'] = String(xApitoken);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Single Batch
         * @param {string} batchId The ID of the batch
         * @param {string} [page] 
         * @param {string} [perPage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSingleBatch: async (batchId: string, page?: string, perPage?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'batchId' is not null or undefined
            assertParamExists('getSingleBatch', 'batchId', batchId)
            const localVarPath = `/v2/batch/{batch_id}.json`
                .replace(`{${"batch_id"}}`, encodeURIComponent(String(batchId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "X-ApiToken", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Single Group
         * @param {string} groupId Group ID
         * @param {string} [accept] 
         * @param {boolean} [associations] Set to &#x60;true&#x60; in order to see each group\&#39;s assigned &#x60;member_ids&#x60;, &#x60;layer_ids&#x60;, &#x60;project_ids&#x60; and &#x60;form_ids&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSingleGroup: async (groupId: string, accept?: string, associations?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('getSingleGroup', 'groupId', groupId)
            const localVarPath = `/v2/groups/{group_id}.json`
                .replace(`{${"group_id"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "X-ApiToken", configuration)

            if (associations !== undefined) {
                localVarQueryParameter['associations'] = associations;
            }


    
            if (accept != null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Single Report Template
         * @param {string} id The id of the report
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSingleReportTemplate: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getSingleReportTemplate', 'id', id)
            const localVarPath = `/v2/report_templates/{id}.json`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "X-ApiToken", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Single Workflow
         * @param {string} workflowId The id of the workflow
         * @param {string} [accept] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSingleWorkflow: async (workflowId: string, accept?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workflowId' is not null or undefined
            assertParamExists('getSingleWorkflow', 'workflowId', workflowId)
            const localVarPath = `/v2/workflows/{workflow_id}.json`
                .replace(`{${"workflow_id"}}`, encodeURIComponent(String(workflowId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "X-ApiToken", configuration)


    
            if (accept != null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create Layer
         * @param {string} [accept] 
         * @param {string} [contentType] 
         * @param {LayersCreateRequest} [layersCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        layersCreate: async (accept?: string, contentType?: string, layersCreateRequest?: LayersCreateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/layers.json`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "X-ApiToken", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (accept != null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(layersCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Layer
         * @param {string} layerId Layer ID
         * @param {string} [accept] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        layersDelete: async (layerId: string, accept?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'layerId' is not null or undefined
            assertParamExists('layersDelete', 'layerId', layerId)
            const localVarPath = `/v2/layers/{layer_id}.json`
                .replace(`{${"layer_id"}}`, encodeURIComponent(String(layerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "X-ApiToken", configuration)


    
            if (accept != null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get All Layers
         * @param {number} [page] The page number requested
         * @param {number} [perPage] Number of items per page
         * @param {string} [accept] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        layersGetAll: async (page?: number, perPage?: number, accept?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/layers.json`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "X-ApiToken", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }


    
            if (accept != null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Single Layer
         * @param {string} layerId Layer ID
         * @param {string} [accept] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        layersGetSingle: async (layerId: string, accept?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'layerId' is not null or undefined
            assertParamExists('layersGetSingle', 'layerId', layerId)
            const localVarPath = `/v2/layers/{layer_id}.json`
                .replace(`{${"layer_id"}}`, encodeURIComponent(String(layerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "X-ApiToken", configuration)


    
            if (accept != null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Layer
         * @param {string} layerId Layer ID
         * @param {string} [accept] 
         * @param {string} [contentType] 
         * @param {LayersUpdateRequest} [layersUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        layersUpdate: async (layerId: string, accept?: string, contentType?: string, layersUpdateRequest?: LayersUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'layerId' is not null or undefined
            assertParamExists('layersUpdate', 'layerId', layerId)
            const localVarPath = `/v2/layers/{layer_id}.json`
                .replace(`{${"layer_id"}}`, encodeURIComponent(String(layerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "X-ApiToken", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (accept != null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(layersUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Add or remove membership permissions from layers, forms, or projects
         * @summary Change Permissions
         * @param {string} [accept] 
         * @param {string} [contentType] 
         * @param {MembershipsChangePermissionsRequest} [membershipsChangePermissionsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        membershipsChangePermissions: async (accept?: string, contentType?: string, membershipsChangePermissionsRequest?: MembershipsChangePermissionsRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/memberships/change_permissions.json`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "X-ApiToken", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (accept != null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(membershipsChangePermissionsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get All Memberships
         * @param {string} [formId] Limit members to a specific Form
         * @param {string} [projectId] Limit members to a specific Project
         * @param {string} [layerId] Limit members to a specific Layer
         * @param {number} [page] The page number requested
         * @param {number} [perPage] Number of items per page
         * @param {string} [accept] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        membershipsGetAll: async (formId?: string, projectId?: string, layerId?: string, page?: number, perPage?: number, accept?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/memberships.json`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "X-ApiToken", configuration)

            if (formId !== undefined) {
                localVarQueryParameter['form_id'] = formId;
            }

            if (projectId !== undefined) {
                localVarQueryParameter['project_id'] = projectId;
            }

            if (layerId !== undefined) {
                localVarQueryParameter['layer_id'] = layerId;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }


    
            if (accept != null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Single Membership
         * @param {string} membershipId Membership ID
         * @param {string} [accept] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        membershipsGetSingle: async (membershipId: string, accept?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'membershipId' is not null or undefined
            assertParamExists('membershipsGetSingle', 'membershipId', membershipId)
            const localVarPath = `/v2/memberships/{membership_id}.json`
                .replace(`{${"membership_id"}}`, encodeURIComponent(String(membershipId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "X-ApiToken", configuration)


    
            if (accept != null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get All Photos
         * @param {string} [recordId] The ID of the record with which the photo is associated.
         * @param {string} [formId] The ID of the form with which the photo is associated. Leaving this blank will query against all of your photos.
         * @param {boolean} [newestFirst] If present, photos will be sorted by updated_at date.
         * @param {boolean} [processed] Photo has been completely processed.
         * @param {boolean} [stored] Photo has been completely stored.
         * @param {boolean} [uploaded] Photo has been completely uploaded.
         * @param {number} [page] The page number requested
         * @param {number} [perPage] Number of items per page
         * @param {string} [accept] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        photosGetAllMetadata: async (recordId?: string, formId?: string, newestFirst?: boolean, processed?: boolean, stored?: boolean, uploaded?: boolean, page?: number, perPage?: number, accept?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/photos.json`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "X-ApiToken", configuration)

            if (recordId !== undefined) {
                localVarQueryParameter['record_id'] = recordId;
            }

            if (formId !== undefined) {
                localVarQueryParameter['form_id'] = formId;
            }

            if (newestFirst !== undefined) {
                localVarQueryParameter['newest_first'] = newestFirst;
            }

            if (processed !== undefined) {
                localVarQueryParameter['processed'] = processed;
            }

            if (stored !== undefined) {
                localVarQueryParameter['stored'] = stored;
            }

            if (uploaded !== undefined) {
                localVarQueryParameter['uploaded'] = uploaded;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }


    
            if (accept != null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Single Photo File
         * @param {string} photoId Photo ID
         * @param {string} [accept] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        photosGetSingleFile: async (photoId: string, accept?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'photoId' is not null or undefined
            assertParamExists('photosGetSingleFile', 'photoId', photoId)
            const localVarPath = `/v2/photos/{photo_id}.jpg`
                .replace(`{${"photo_id"}}`, encodeURIComponent(String(photoId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "X-ApiToken", configuration)


    
            if (accept != null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Single Photo Metadata
         * @param {string} photoId Photo ID
         * @param {string} [accept] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        photosGetSingleMetadata: async (photoId: string, accept?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'photoId' is not null or undefined
            assertParamExists('photosGetSingleMetadata', 'photoId', photoId)
            const localVarPath = `/v2/photos/{photo_id}.json`
                .replace(`{${"photo_id"}}`, encodeURIComponent(String(photoId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "X-ApiToken", configuration)


    
            if (accept != null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Photo Large File
         * @param {string} photoId Photo ID
         * @param {string} [accept] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        photosLargeFile: async (photoId: string, accept?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'photoId' is not null or undefined
            assertParamExists('photosLargeFile', 'photoId', photoId)
            const localVarPath = `/v2/photos/{photo_id}/large.jpg`
                .replace(`{${"photo_id"}}`, encodeURIComponent(String(photoId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "X-ApiToken", configuration)


    
            if (accept != null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Photo Large Metadata
         * @param {string} photoId Photo ID
         * @param {string} [accept] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        photosLargeMetadata: async (photoId: string, accept?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'photoId' is not null or undefined
            assertParamExists('photosLargeMetadata', 'photoId', photoId)
            const localVarPath = `/v2/photos/{photo_id}/large.json`
                .replace(`{${"photo_id"}}`, encodeURIComponent(String(photoId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "X-ApiToken", configuration)


    
            if (accept != null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Photo Thumbnail File
         * @param {string} photoId Photo ID
         * @param {string} [accept] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        photosThumbnailFile: async (photoId: string, accept?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'photoId' is not null or undefined
            assertParamExists('photosThumbnailFile', 'photoId', photoId)
            const localVarPath = `/v2/photos/{photo_id}/thumbnail.jpg`
                .replace(`{${"photo_id"}}`, encodeURIComponent(String(photoId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "X-ApiToken", configuration)


    
            if (accept != null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Photo Thumbnail Metadata
         * @param {string} photoId Photo ID
         * @param {string} [accept] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        photosThumbnailMetadata: async (photoId: string, accept?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'photoId' is not null or undefined
            assertParamExists('photosThumbnailMetadata', 'photoId', photoId)
            const localVarPath = `/v2/photos/{photo_id}/thumbnail.json`
                .replace(`{${"photo_id"}}`, encodeURIComponent(String(photoId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "X-ApiToken", configuration)


    
            if (accept != null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Upload Photo
         * @param {string} [accept] 
         * @param {string} [contentType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        photosUpload: async (accept?: string, contentType?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/photos.json`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "X-ApiToken", configuration)


    
            if (accept != null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create Project
         * @param {string} [accept] 
         * @param {string} [contentType] 
         * @param {ProjectsCreateRequest} [projectsCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsCreate: async (accept?: string, contentType?: string, projectsCreateRequest?: ProjectsCreateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/projects.json`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "X-ApiToken", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (accept != null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(projectsCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Project
         * @param {string} projectId Project ID
         * @param {string} [accept] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsDelete: async (projectId: string, accept?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('projectsDelete', 'projectId', projectId)
            const localVarPath = `/v2/projects/{project_id}.json`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "X-ApiToken", configuration)


    
            if (accept != null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get All Projects
         * @param {number} [page] The page number requested
         * @param {number} [perPage] Number of items per page
         * @param {string} [accept] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsGetAll: async (page?: number, perPage?: number, accept?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/projects.json`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "X-ApiToken", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }


    
            if (accept != null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Single Project
         * @param {string} projectId Project ID
         * @param {string} [accept] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsGetSingle: async (projectId: string, accept?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('projectsGetSingle', 'projectId', projectId)
            const localVarPath = `/v2/projects/{project_id}.json`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "X-ApiToken", configuration)


    
            if (accept != null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Project
         * @param {string} projectId Project ID
         * @param {string} [accept] 
         * @param {string} [contentType] 
         * @param {ProjectsUpdateRequest} [projectsUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsUpdate: async (projectId: string, accept?: string, contentType?: string, projectsUpdateRequest?: ProjectsUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('projectsUpdate', 'projectId', projectId)
            const localVarPath = `/v2/projects/{project_id}.json`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "X-ApiToken", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (accept != null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(projectsUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary GET Query
         * @param {string} q The SQL query
         * @param {string} [format] The format of the results returned by the query. Options include &#x60;csv&#x60;, &#x60;json&#x60;, &#x60;geojson&#x60;, &#x60;postgres&#x60;.
         * @param {boolean} [headers] Include headers for csv format?
         * @param {boolean} [metadata] Include column metadata for &#x60;json&#x60; format?
         * @param {boolean} [arrays] Return row arrays instead of objects for &#x60;json&#x60; format?
         * @param {string} [tableName] Table name for &#x60;postgres&#x60; format. Defaults to query.
         * @param {string} [sortColumn] The name of the column used to sort on.
         * @param {string} [sortDirection] The sort direction (asc, desc).
         * @param {number} [page] The page number requested
         * @param {number} [perPage] Number of items per page
         * @param {string} [accept] 
         * @param {string} [userAgent] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queryGet: async (q: string, format?: string, headers?: boolean, metadata?: boolean, arrays?: boolean, tableName?: string, sortColumn?: string, sortDirection?: string, page?: number, perPage?: number, accept?: string, userAgent?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'q' is not null or undefined
            assertParamExists('queryGet', 'q', q)
            const localVarPath = `/v2/query`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "X-ApiToken", configuration)

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }

            if (headers !== undefined) {
                localVarQueryParameter['headers'] = headers;
            }

            if (metadata !== undefined) {
                localVarQueryParameter['metadata'] = metadata;
            }

            if (arrays !== undefined) {
                localVarQueryParameter['arrays'] = arrays;
            }

            if (tableName !== undefined) {
                localVarQueryParameter['table_name'] = tableName;
            }

            if (sortColumn !== undefined) {
                localVarQueryParameter['sort_column'] = sortColumn;
            }

            if (sortDirection !== undefined) {
                localVarQueryParameter['sort_direction'] = sortDirection;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }


    
            if (accept != null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }
            if (userAgent != null) {
                localVarHeaderParameter['User-Agent'] = String(userAgent);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary POST Query
         * @param {number} [page] The page number requested
         * @param {number} [perPage] Number of items per page
         * @param {string} [accept] 
         * @param {QueryPostRequest} [queryPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queryPost: async (page?: number, perPage?: number, accept?: string, queryPostRequest?: QueryPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/query`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "X-ApiToken", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (accept != null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(queryPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create Record
         * @param {string} [accept] 
         * @param {string} [contentType] 
         * @param {boolean} [xSkipWorkflows] Skips all app workflows
         * @param {boolean} [xSkipWebhooks] Skips all app webhooks
         * @param {RecordsCreateRequest} [recordsCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recordsCreate: async (accept?: string, contentType?: string, xSkipWorkflows?: boolean, xSkipWebhooks?: boolean, recordsCreateRequest?: RecordsCreateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/records.json`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "X-ApiToken", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (accept != null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (xSkipWorkflows != null) {
                localVarHeaderParameter['X-SkipWorkflows'] = typeof xSkipWorkflows === 'string'
                    ? xSkipWorkflows
                    : JSON.stringify(xSkipWorkflows);
            }
            if (xSkipWebhooks != null) {
                localVarHeaderParameter['X-SkipWebhooks'] = typeof xSkipWebhooks === 'string'
                    ? xSkipWebhooks
                    : JSON.stringify(xSkipWebhooks);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(recordsCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Record
         * @param {string} recordId Record ID
         * @param {string} [accept] 
         * @param {boolean} [xSkipWorkflows] Skips all app workflows
         * @param {boolean} [xSkipWebhooks] Skips all app webhooks
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recordsDelete: async (recordId: string, accept?: string, xSkipWorkflows?: boolean, xSkipWebhooks?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'recordId' is not null or undefined
            assertParamExists('recordsDelete', 'recordId', recordId)
            const localVarPath = `/v2/records/{record_id}.json`
                .replace(`{${"record_id"}}`, encodeURIComponent(String(recordId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "X-ApiToken", configuration)


    
            if (accept != null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }
            if (xSkipWorkflows != null) {
                localVarHeaderParameter['X-SkipWorkflows'] = typeof xSkipWorkflows === 'string'
                    ? xSkipWorkflows
                    : JSON.stringify(xSkipWorkflows);
            }
            if (xSkipWebhooks != null) {
                localVarHeaderParameter['X-SkipWebhooks'] = typeof xSkipWebhooks === 'string'
                    ? xSkipWebhooks
                    : JSON.stringify(xSkipWebhooks);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get All Records
         * @param {boolean} [newestFirst] If present, records will be sorted by updated_at date.
         * @param {string} [boundingBox] Bounding box of the records requested. Format should be: lat,long,lat,long (bottom, left, top, right).
         * @param {string} [changesetId] The id of the changeset associated with the record.
         * @param {string} [formId] The id of the form with which the record is associated. Leaving this blank will query against all of your records.
         * @param {string} [projectId] The id of the project with which the record is associated. Leaving this blank will query against all of your records.
         * @param {string} [clientCreatedBefore] Return only records which were created by the client (device) before the given time.
         * @param {string} [clientCreatedSince] Return only records which were created by the client (device) after the given time.
         * @param {string} [clientUpdatedBefore] Return only records which were updated by the client (device) before the given time.
         * @param {string} [clientUpdatedSince] Return only records which were updated by the client (device) after the given time.
         * @param {string} [createdBefore] Return only records which were created (on the server) before the given time.
         * @param {string} [createdSince] Return only records which were created (on the server) after the given time.
         * @param {string} [updatedBefore] Return only records which were updated (on the server) before the given time.
         * @param {string} [updatedSince] Return only records which were updated (on the server) after the given time.
         * @param {number} [page] The page number requested
         * @param {number} [perPage] Number of items per page
         * @param {string} [accept] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recordsGetAll: async (newestFirst?: boolean, boundingBox?: string, changesetId?: string, formId?: string, projectId?: string, clientCreatedBefore?: string, clientCreatedSince?: string, clientUpdatedBefore?: string, clientUpdatedSince?: string, createdBefore?: string, createdSince?: string, updatedBefore?: string, updatedSince?: string, page?: number, perPage?: number, accept?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/records.json`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "X-ApiToken", configuration)

            if (newestFirst !== undefined) {
                localVarQueryParameter['newest_first'] = newestFirst;
            }

            if (boundingBox !== undefined) {
                localVarQueryParameter['bounding_box'] = boundingBox;
            }

            if (changesetId !== undefined) {
                localVarQueryParameter['changeset_id'] = changesetId;
            }

            if (formId !== undefined) {
                localVarQueryParameter['form_id'] = formId;
            }

            if (projectId !== undefined) {
                localVarQueryParameter['project_id'] = projectId;
            }

            if (clientCreatedBefore !== undefined) {
                localVarQueryParameter['client_created_before'] = (clientCreatedBefore as any instanceof Date) ?
                    (clientCreatedBefore as any).toISOString() :
                    clientCreatedBefore;
            }

            if (clientCreatedSince !== undefined) {
                localVarQueryParameter['client_created_since'] = (clientCreatedSince as any instanceof Date) ?
                    (clientCreatedSince as any).toISOString() :
                    clientCreatedSince;
            }

            if (clientUpdatedBefore !== undefined) {
                localVarQueryParameter['client_updated_before'] = (clientUpdatedBefore as any instanceof Date) ?
                    (clientUpdatedBefore as any).toISOString() :
                    clientUpdatedBefore;
            }

            if (clientUpdatedSince !== undefined) {
                localVarQueryParameter['client_updated_since'] = (clientUpdatedSince as any instanceof Date) ?
                    (clientUpdatedSince as any).toISOString() :
                    clientUpdatedSince;
            }

            if (createdBefore !== undefined) {
                localVarQueryParameter['created_before'] = (createdBefore as any instanceof Date) ?
                    (createdBefore as any).toISOString() :
                    createdBefore;
            }

            if (createdSince !== undefined) {
                localVarQueryParameter['created_since'] = (createdSince as any instanceof Date) ?
                    (createdSince as any).toISOString() :
                    createdSince;
            }

            if (updatedBefore !== undefined) {
                localVarQueryParameter['updated_before'] = (updatedBefore as any instanceof Date) ?
                    (updatedBefore as any).toISOString() :
                    updatedBefore;
            }

            if (updatedSince !== undefined) {
                localVarQueryParameter['updated_since'] = (updatedSince as any instanceof Date) ?
                    (updatedSince as any).toISOString() :
                    updatedSince;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }


    
            if (accept != null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint can help you get records from a specific changeset, or retrieve records for a deleted form.
         * @summary Get All Records History
         * @param {string} [accept] 
         * @param {string} [changesetId] 
         * @param {string} [deletedFormId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recordsGetAllHistory: async (accept?: string, changesetId?: string, deletedFormId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/records/history.json`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "X-ApiToken", configuration)

            if (changesetId !== undefined) {
                localVarQueryParameter['changeset_id'] = changesetId;
            }

            if (deletedFormId !== undefined) {
                localVarQueryParameter['deleted_form_id'] = deletedFormId;
            }


    
            if (accept != null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Record History
         * @param {string} recordId Record ID
         * @param {string} [accept] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recordsGetHistory: async (recordId: string, accept?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'recordId' is not null or undefined
            assertParamExists('recordsGetHistory', 'recordId', recordId)
            const localVarPath = `/v2/records/{record_id}/history.json`
                .replace(`{${"record_id"}}`, encodeURIComponent(String(recordId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "X-ApiToken", configuration)


    
            if (accept != null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Single Record
         * @param {string} recordId Record ID
         * @param {string} [accept] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recordsGetSingle: async (recordId: string, accept?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'recordId' is not null or undefined
            assertParamExists('recordsGetSingle', 'recordId', recordId)
            const localVarPath = `/v2/records/{record_id}.json`
                .replace(`{${"record_id"}}`, encodeURIComponent(String(recordId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "X-ApiToken", configuration)


    
            if (accept != null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Record
         * @param {string} recordId Record ID
         * @param {string} [accept] 
         * @param {string} [contentType] 
         * @param {boolean} [xSkipWorkflows] Skips all app workflows
         * @param {boolean} [xSkipWebhooks] Skips all app webhooks
         * @param {RecordsUpdateRequest} [recordsUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recordsUpdate: async (recordId: string, accept?: string, contentType?: string, xSkipWorkflows?: boolean, xSkipWebhooks?: boolean, recordsUpdateRequest?: RecordsUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'recordId' is not null or undefined
            assertParamExists('recordsUpdate', 'recordId', recordId)
            const localVarPath = `/v2/records/{record_id}.json`
                .replace(`{${"record_id"}}`, encodeURIComponent(String(recordId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "X-ApiToken", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (accept != null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (xSkipWorkflows != null) {
                localVarHeaderParameter['X-SkipWorkflows'] = typeof xSkipWorkflows === 'string'
                    ? xSkipWorkflows
                    : JSON.stringify(xSkipWorkflows);
            }
            if (xSkipWebhooks != null) {
                localVarHeaderParameter['X-SkipWebhooks'] = typeof xSkipWebhooks === 'string'
                    ? xSkipWebhooks
                    : JSON.stringify(xSkipWebhooks);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(recordsUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get All Roles
         * @param {number} [page] The page number requested
         * @param {number} [perPage] Number of items per page
         * @param {string} [accept] 
         * @param {string} [sort] Sort by role name. Default sort is by &#x60;updated_at&#x60; if sort is not provided
         * @param {string} [sortDirection] The sort direction (asc, desc). Default is &#x60;asc&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolesGetAll: async (page?: number, perPage?: number, accept?: string, sort?: string, sortDirection?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/roles.json`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "X-ApiToken", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (sortDirection !== undefined) {
                localVarQueryParameter['sort_direction'] = sortDirection;
            }


    
            if (accept != null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get All Signatures
         * @param {string} [recordId] The ID of the record with which the photo is associated.
         * @param {string} [formId] The ID of the form with which the photo is associated. Leaving this blank will query against all of your photos.
         * @param {boolean} [newestFirst] If present, photos will be sorted by updated_at date.
         * @param {boolean} [processed] Signature has been completely processed.
         * @param {boolean} [stored] Signature has been completely stored.
         * @param {boolean} [uploaded] Signature has been completely uploaded.
         * @param {number} [page] The page number requested
         * @param {number} [perPage] Number of items per page
         * @param {string} [accept] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signaturesGetAll: async (recordId?: string, formId?: string, newestFirst?: boolean, processed?: boolean, stored?: boolean, uploaded?: boolean, page?: number, perPage?: number, accept?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/signatures.json`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "X-ApiToken", configuration)

            if (recordId !== undefined) {
                localVarQueryParameter['record_id'] = recordId;
            }

            if (formId !== undefined) {
                localVarQueryParameter['form_id'] = formId;
            }

            if (newestFirst !== undefined) {
                localVarQueryParameter['newest_first'] = newestFirst;
            }

            if (processed !== undefined) {
                localVarQueryParameter['processed'] = processed;
            }

            if (stored !== undefined) {
                localVarQueryParameter['stored'] = stored;
            }

            if (uploaded !== undefined) {
                localVarQueryParameter['uploaded'] = uploaded;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }


    
            if (accept != null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Single Signature File
         * @param {string} signatureId Signature ID
         * @param {string} [accept] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signaturesGetSingleFile: async (signatureId: string, accept?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'signatureId' is not null or undefined
            assertParamExists('signaturesGetSingleFile', 'signatureId', signatureId)
            const localVarPath = `/v2/signatures/{signature_id}.png`
                .replace(`{${"signature_id"}}`, encodeURIComponent(String(signatureId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "X-ApiToken", configuration)


    
            if (accept != null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Single Signature Metadata
         * @param {string} signatureId Signature ID
         * @param {string} [accept] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signaturesGetSingleMetadata: async (signatureId: string, accept?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'signatureId' is not null or undefined
            assertParamExists('signaturesGetSingleMetadata', 'signatureId', signatureId)
            const localVarPath = `/v2/signatures/{signature_id}.json`
                .replace(`{${"signature_id"}}`, encodeURIComponent(String(signatureId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "X-ApiToken", configuration)


    
            if (accept != null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Signature Thumbnail File
         * @param {string} signatureId Signature ID
         * @param {string} [accept] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signaturesGetThumbnailFile: async (signatureId: string, accept?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'signatureId' is not null or undefined
            assertParamExists('signaturesGetThumbnailFile', 'signatureId', signatureId)
            const localVarPath = `/v2/signatures/{signature_id}/thumbnail.png`
                .replace(`{${"signature_id"}}`, encodeURIComponent(String(signatureId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "X-ApiToken", configuration)


    
            if (accept != null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Signature Thumbnail Metadata
         * @param {string} signatureId Signature ID
         * @param {string} [accept] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signaturesGetThumbnailMetadata: async (signatureId: string, accept?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'signatureId' is not null or undefined
            assertParamExists('signaturesGetThumbnailMetadata', 'signatureId', signatureId)
            const localVarPath = `/v2/signatures/{signature_id}/thumbnail.json`
                .replace(`{${"signature_id"}}`, encodeURIComponent(String(signatureId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "X-ApiToken", configuration)


    
            if (accept != null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Upload Signature
         * @param {string} [accept] 
         * @param {string} [contentType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signaturesUpload: async (accept?: string, contentType?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/signatures.json`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "X-ApiToken", configuration)


    
            if (accept != null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Start your pending batch
         * @summary Start Batch
         * @param {string} batchId ID of the batch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startBatch: async (batchId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'batchId' is not null or undefined
            assertParamExists('startBatch', 'batchId', batchId)
            const localVarPath = `/v2/batch/{batch_id}/start.json`
                .replace(`{${"batch_id"}}`, encodeURIComponent(String(batchId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "X-ApiToken", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Group Name / Description
         * @param {string} groupId ID of the group
         * @param {string} [accept] 
         * @param {string} [contentType] 
         * @param {UpdateGroupNameDescriptionRequest} [updateGroupNameDescriptionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGroupNameDescription: async (groupId: string, accept?: string, contentType?: string, updateGroupNameDescriptionRequest?: UpdateGroupNameDescriptionRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('updateGroupNameDescription', 'groupId', groupId)
            const localVarPath = `/v2/groups/{group_id}.json`
                .replace(`{${"group_id"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "X-ApiToken", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (accept != null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateGroupNameDescriptionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Group Permissions
         * @param {string} [accept] 
         * @param {string} [contentType] 
         * @param {UpdateGroupPermissionsRequest} [updateGroupPermissionsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGroupPermissions: async (accept?: string, contentType?: string, updateGroupPermissionsRequest?: UpdateGroupPermissionsRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/groups/change_permissions.json`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "X-ApiToken", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (accept != null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateGroupPermissionsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * You can use this to update parameters of a member, but this will not work if the member is apart of multiple organizations.
         * @summary Update Member
         * @param {string} membershipId The ID of the member
         * @param {UpdateMemberRequest} [updateMemberRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMember: async (membershipId: string, updateMemberRequest?: UpdateMemberRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'membershipId' is not null or undefined
            assertParamExists('updateMember', 'membershipId', membershipId)
            const localVarPath = `/v2/memberships/{membership_id}.json`
                .replace(`{${"membership_id"}}`, encodeURIComponent(String(membershipId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "X-ApiToken", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateMemberRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Report Template
         * @param {string} id The id of the report
         * @param {UpdateReportTemplateRequest} [updateReportTemplateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateReportTemplate: async (id: string, updateReportTemplateRequest?: UpdateReportTemplateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateReportTemplate', 'id', id)
            const localVarPath = `/v2/report_templates/{id}.json`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "X-ApiToken", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateReportTemplateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Workflow
         * @param {string} workflowId The ID of the workflow
         * @param {string} [accept] 
         * @param {string} [contentTyoe] 
         * @param {UpdateWorkflowRequest} [updateWorkflowRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWorkflow: async (workflowId: string, accept?: string, contentTyoe?: string, updateWorkflowRequest?: UpdateWorkflowRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workflowId' is not null or undefined
            assertParamExists('updateWorkflow', 'workflowId', workflowId)
            const localVarPath = `/v2/workflows/{workflow_id}.json`
                .replace(`{${"workflow_id"}}`, encodeURIComponent(String(workflowId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "X-ApiToken", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (accept != null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }
            if (contentTyoe != null) {
                localVarHeaderParameter['Content-Tyoe'] = String(contentTyoe);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateWorkflowRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get User Information
         * @param {number} [page] The page number requested
         * @param {number} [perPage] Number of items per page
         * @param {string} [accept] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersGetUser: async (page?: number, perPage?: number, accept?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/users.json`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "X-ApiToken", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }


    
            if (accept != null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get All Videos
         * @param {string} [recordId] The ID of the record with which the video is associated.
         * @param {string} [formId] The ID of the form with which the video is associated. Leaving this blank will query against all of your videos.
         * @param {boolean} [newestFirst] If present, videos will be sorted by updated_at date.
         * @param {boolean} [processed] Video has been completely processed.
         * @param {boolean} [stored] Video has been completely stored.
         * @param {boolean} [uploaded] Video has been completely uploaded.
         * @param {number} [page] The page number requested
         * @param {number} [perPage] Number of items per page
         * @param {string} [accept] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        videosGetAll: async (recordId?: string, formId?: string, newestFirst?: boolean, processed?: boolean, stored?: boolean, uploaded?: boolean, page?: number, perPage?: number, accept?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/videos.json`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "X-ApiToken", configuration)

            if (recordId !== undefined) {
                localVarQueryParameter['record_id'] = recordId;
            }

            if (formId !== undefined) {
                localVarQueryParameter['form_id'] = formId;
            }

            if (newestFirst !== undefined) {
                localVarQueryParameter['newest_first'] = newestFirst;
            }

            if (processed !== undefined) {
                localVarQueryParameter['processed'] = processed;
            }

            if (stored !== undefined) {
                localVarQueryParameter['stored'] = stored;
            }

            if (uploaded !== undefined) {
                localVarQueryParameter['uploaded'] = uploaded;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }


    
            if (accept != null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get GeoJSON Tracks for All Videos
         * @param {string} [accept] 
         * @param {string} [type] Set value to &#x60;points&#x60; to fetch tracks as GeoJSON points
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        videosGetAllTracksGeojson: async (accept?: string, type?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/videos/tracks.geojson`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "X-ApiToken", configuration)

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }


    
            if (accept != null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get GPX Tracks for All Videos
         * @param {string} [accept] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        videosGetAllTracksGpx: async (accept?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/videos/tracks.gpx`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "X-ApiToken", configuration)


    
            if (accept != null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get KML Tracks for All Videos
         * @param {string} [accept] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        videosGetAllTracksKml: async (accept?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/videos/tracks.kml`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "X-ApiToken", configuration)


    
            if (accept != null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Medium Video File
         * @param {string} videoId Video ID
         * @param {string} [accept] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        videosGetMediumFile: async (videoId: string, accept?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'videoId' is not null or undefined
            assertParamExists('videosGetMediumFile', 'videoId', videoId)
            const localVarPath = `/v2/videos/{video_id}/medium.mp4`
                .replace(`{${"video_id"}}`, encodeURIComponent(String(videoId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "X-ApiToken", configuration)


    
            if (accept != null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Original Video File
         * @param {string} videoId Video ID
         * @param {string} [accept] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        videosGetOriginalFile: async (videoId: string, accept?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'videoId' is not null or undefined
            assertParamExists('videosGetOriginalFile', 'videoId', videoId)
            const localVarPath = `/v2/videos/{video_id}.mp4`
                .replace(`{${"video_id"}}`, encodeURIComponent(String(videoId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "X-ApiToken", configuration)


    
            if (accept != null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Video Metadata
         * @param {string} videoId Video ID
         * @param {string} [accept] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        videosGetSingleMetadata: async (videoId: string, accept?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'videoId' is not null or undefined
            assertParamExists('videosGetSingleMetadata', 'videoId', videoId)
            const localVarPath = `/v2/videos/{video_id}.json`
                .replace(`{${"video_id"}}`, encodeURIComponent(String(videoId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "X-ApiToken", configuration)


    
            if (accept != null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get GeoJSON Video Track
         * @param {string} videoId Video ID
         * @param {string} [accept] 
         * @param {string} [type] Set value to &#x60;points&#x60; to fetch tracks as GeoJSON points
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        videosGetSingleTrackGeojson: async (videoId: string, accept?: string, type?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'videoId' is not null or undefined
            assertParamExists('videosGetSingleTrackGeojson', 'videoId', videoId)
            const localVarPath = `/v2/videos/{video_id}/track.geojson`
                .replace(`{${"video_id"}}`, encodeURIComponent(String(videoId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "X-ApiToken", configuration)

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }


    
            if (accept != null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get GPX Video Track
         * @param {string} videoId Video ID
         * @param {string} [accept] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        videosGetSingleTrackGpx: async (videoId: string, accept?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'videoId' is not null or undefined
            assertParamExists('videosGetSingleTrackGpx', 'videoId', videoId)
            const localVarPath = `/v2/videos/{video_id}/track.gpx`
                .replace(`{${"video_id"}}`, encodeURIComponent(String(videoId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "X-ApiToken", configuration)


    
            if (accept != null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get JSON Video Track
         * @param {string} videoId Video ID
         * @param {string} [accept] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        videosGetSingleTrackJson: async (videoId: string, accept?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'videoId' is not null or undefined
            assertParamExists('videosGetSingleTrackJson', 'videoId', videoId)
            const localVarPath = `/v2/videos/{video_id}/track.json`
                .replace(`{${"video_id"}}`, encodeURIComponent(String(videoId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "X-ApiToken", configuration)


    
            if (accept != null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get KML Video Track
         * @param {string} videoId Video ID
         * @param {string} [accept] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        videosGetSingleTrackKml: async (videoId: string, accept?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'videoId' is not null or undefined
            assertParamExists('videosGetSingleTrackKml', 'videoId', videoId)
            const localVarPath = `/v2/videos/{video_id}/track.kml`
                .replace(`{${"video_id"}}`, encodeURIComponent(String(videoId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "X-ApiToken", configuration)


    
            if (accept != null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Small Video File
         * @param {string} videoId Video ID
         * @param {string} [accept] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        videosGetSmallFile: async (videoId: string, accept?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'videoId' is not null or undefined
            assertParamExists('videosGetSmallFile', 'videoId', videoId)
            const localVarPath = `/v2/videos/{video_id}/small.mp4`
                .replace(`{${"video_id"}}`, encodeURIComponent(String(videoId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "X-ApiToken", configuration)


    
            if (accept != null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Huge Video Thumbnail
         * @param {string} videoId Video ID
         * @param {string} [accept] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        videosGetThumbnailHuge: async (videoId: string, accept?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'videoId' is not null or undefined
            assertParamExists('videosGetThumbnailHuge', 'videoId', videoId)
            const localVarPath = `/v2/videos/{video_id}/thumbnail_huge.jpg`
                .replace(`{${"video_id"}}`, encodeURIComponent(String(videoId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "X-ApiToken", configuration)


    
            if (accept != null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Huge Square Video Thumbnail
         * @param {string} videoId Video ID
         * @param {string} [accept] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        videosGetThumbnailHugeSquare: async (videoId: string, accept?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'videoId' is not null or undefined
            assertParamExists('videosGetThumbnailHugeSquare', 'videoId', videoId)
            const localVarPath = `/v2/videos/{video_id}/thumbnail_huge_square.jpg`
                .replace(`{${"video_id"}}`, encodeURIComponent(String(videoId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "X-ApiToken", configuration)


    
            if (accept != null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Large Video Thumbnail
         * @param {string} videoId Video ID
         * @param {string} [accept] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        videosGetThumbnailLarge: async (videoId: string, accept?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'videoId' is not null or undefined
            assertParamExists('videosGetThumbnailLarge', 'videoId', videoId)
            const localVarPath = `/v2/videos/{video_id}/thumbnail_large.jpg`
                .replace(`{${"video_id"}}`, encodeURIComponent(String(videoId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "X-ApiToken", configuration)


    
            if (accept != null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Large Square Video Thumbnail
         * @param {string} videoId Video ID
         * @param {string} [accept] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        videosGetThumbnailLargeSquare: async (videoId: string, accept?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'videoId' is not null or undefined
            assertParamExists('videosGetThumbnailLargeSquare', 'videoId', videoId)
            const localVarPath = `/v2/videos/{video_id}/thumbnail_large_square.jpg`
                .replace(`{${"video_id"}}`, encodeURIComponent(String(videoId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "X-ApiToken", configuration)


    
            if (accept != null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Medium Video Thumbnail
         * @param {string} videoId Video ID
         * @param {string} [accept] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        videosGetThumbnailMedium: async (videoId: string, accept?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'videoId' is not null or undefined
            assertParamExists('videosGetThumbnailMedium', 'videoId', videoId)
            const localVarPath = `/v2/videos/{video_id}/thumbnail_medium.jpg`
                .replace(`{${"video_id"}}`, encodeURIComponent(String(videoId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "X-ApiToken", configuration)


    
            if (accept != null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Medium Square Video Thumbnail
         * @param {string} videoId Video ID
         * @param {string} [accept] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        videosGetThumbnailMediumSquare: async (videoId: string, accept?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'videoId' is not null or undefined
            assertParamExists('videosGetThumbnailMediumSquare', 'videoId', videoId)
            const localVarPath = `/v2/videos/{video_id}/thumbnail_medium_square.jpg`
                .replace(`{${"video_id"}}`, encodeURIComponent(String(videoId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "X-ApiToken", configuration)


    
            if (accept != null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Small Video Thumbnail
         * @param {string} videoId Video ID
         * @param {string} [accept] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        videosGetThumbnailSmall: async (videoId: string, accept?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'videoId' is not null or undefined
            assertParamExists('videosGetThumbnailSmall', 'videoId', videoId)
            const localVarPath = `/v2/videos/{video_id}/thumbnail_small.jpg`
                .replace(`{${"video_id"}}`, encodeURIComponent(String(videoId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "X-ApiToken", configuration)


    
            if (accept != null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Small Square Video Thumbnail
         * @param {string} videoId Video ID
         * @param {string} [accept] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        videosGetThumbnailSmallSquare: async (videoId: string, accept?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'videoId' is not null or undefined
            assertParamExists('videosGetThumbnailSmallSquare', 'videoId', videoId)
            const localVarPath = `/v2/videos/{video_id}/thumbnail_small_square.jpg`
                .replace(`{${"video_id"}}`, encodeURIComponent(String(videoId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "X-ApiToken", configuration)


    
            if (accept != null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Upload video with optional track file
         * @summary Upload Video
         * @param {string} [accept] 
         * @param {string} [contentType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        videosUpload: async (accept?: string, contentType?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/videos/upload.json`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "X-ApiToken", configuration)


    
            if (accept != null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create Webhook
         * @param {string} [accept] 
         * @param {string} [contentType] 
         * @param {WebhooksCreateRequest} [webhooksCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhooksCreate: async (accept?: string, contentType?: string, webhooksCreateRequest?: WebhooksCreateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/webhooks.json`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "X-ApiToken", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (accept != null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(webhooksCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Webhook
         * @param {string} webhookId Webhook ID
         * @param {string} [accept] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhooksDelete: async (webhookId: string, accept?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'webhookId' is not null or undefined
            assertParamExists('webhooksDelete', 'webhookId', webhookId)
            const localVarPath = `/v2/webhooks/{webhook_id}.json`
                .replace(`{${"webhook_id"}}`, encodeURIComponent(String(webhookId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "X-ApiToken", configuration)


    
            if (accept != null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get All Webhooks
         * @param {number} [page] The page number requested
         * @param {number} [perPage] Number of items per page
         * @param {string} [accept] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhooksGetAll: async (page?: number, perPage?: number, accept?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/webhooks.json`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "X-ApiToken", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }


    
            if (accept != null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Single Webhook
         * @param {string} webhookId Webhook ID
         * @param {string} [accept] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhooksGetSingle: async (webhookId: string, accept?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'webhookId' is not null or undefined
            assertParamExists('webhooksGetSingle', 'webhookId', webhookId)
            const localVarPath = `/v2/webhooks/{webhook_id}.json`
                .replace(`{${"webhook_id"}}`, encodeURIComponent(String(webhookId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "X-ApiToken", configuration)


    
            if (accept != null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Webhook
         * @param {string} webhookId Webhook ID
         * @param {string} [accept] 
         * @param {string} [contentType] 
         * @param {WebhooksUpdateRequest} [webhooksUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhooksUpdate: async (webhookId: string, accept?: string, contentType?: string, webhooksUpdateRequest?: WebhooksUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'webhookId' is not null or undefined
            assertParamExists('webhooksUpdate', 'webhookId', webhookId)
            const localVarPath = `/v2/webhooks/{webhook_id}.json`
                .replace(`{${"webhook_id"}}`, encodeURIComponent(String(webhookId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "X-ApiToken", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (accept != null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(webhooksUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration)
    return {
        /**
         * Using the batch operations API, you can bulk delete records from a form or update project, assignee, or status values on multiple records.
         * @summary Add batch operations
         * @param {string} batchId ID of the batch
         * @param {AddBatchOperationsRequest} [addBatchOperationsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addBatchOperations(batchId: string, addBatchOperationsRequest?: AddBatchOperationsRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addBatchOperations(batchId, addBatchOperationsRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.addBatchOperations']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get All Audio
         * @param {string} [recordId] The ID of the record with which the video is associated.
         * @param {string} [formId] The ID of the form with which the video is associated. Leaving this blank will query against all of your videos.
         * @param {boolean} [newestFirst] If present, videos will be sorted by updated_at date.
         * @param {boolean} [processed] Video has been completely processed.
         * @param {boolean} [stored] Video has been completely stored.
         * @param {boolean} [uploaded] Video has been completely uploaded.
         * @param {number} [page] The page number requested
         * @param {number} [perPage] Number of items per page
         * @param {string} [accept] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async audioGetAll(recordId?: string, formId?: string, newestFirst?: boolean, processed?: boolean, stored?: boolean, uploaded?: boolean, page?: number, perPage?: number, accept?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.audioGetAll(recordId, formId, newestFirst, processed, stored, uploaded, page, perPage, accept, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.audioGetAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get GeoJSON Tracks for All Audio
         * @param {string} [accept] 
         * @param {string} [type] Set value to &#x60;points&#x60; to fetch tracks as GeoJSON points
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async audioGetAllTracksGeojson(accept?: string, type?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.audioGetAllTracksGeojson(accept, type, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.audioGetAllTracksGeojson']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get GPX Tracks for All Audio
         * @param {string} [accept] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async audioGetAllTracksGpx(accept?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.audioGetAllTracksGpx(accept, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.audioGetAllTracksGpx']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get JSON Tracks for All Audio
         * @param {string} [accept] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async audioGetAllTracksJson(accept?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.audioGetAllTracksJson(accept, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.audioGetAllTracksJson']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get KML Tracks for All Audio
         * @param {string} [accept] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async audioGetAllTracksKml(accept?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.audioGetAllTracksKml(accept, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.audioGetAllTracksKml']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Original Audio File
         * @param {string} audioId Audio ID
         * @param {string} [accept] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async audioGetOriginalFile(audioId: string, accept?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.audioGetOriginalFile(audioId, accept, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.audioGetOriginalFile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Audio Metadata
         * @param {string} audioId Audio ID
         * @param {string} [accept] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async audioGetSingleMetadata(audioId: string, accept?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.audioGetSingleMetadata(audioId, accept, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.audioGetSingleMetadata']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get GeoJSON Audio Track
         * @param {string} audioId Audio ID
         * @param {string} [accept] 
         * @param {string} [type] Set value to &#x60;points&#x60; to fetch tracks as GeoJSON points
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async audioGetSingleTrackGeojson(audioId: string, accept?: string, type?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.audioGetSingleTrackGeojson(audioId, accept, type, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.audioGetSingleTrackGeojson']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get GPX Audio Track
         * @param {string} audioId Audio ID
         * @param {string} [accept] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async audioGetSingleTrackGpx(audioId: string, accept?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.audioGetSingleTrackGpx(audioId, accept, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.audioGetSingleTrackGpx']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get JSON Audio Track
         * @param {string} audioId Audio ID
         * @param {string} [accept] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async audioGetSingleTrackJson(audioId: string, accept?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.audioGetSingleTrackJson(audioId, accept, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.audioGetSingleTrackJson']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get KML Audio Track
         * @param {string} audioId Audio ID
         * @param {string} [accept] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async audioGetSingleTrackKml(audioId: string, accept?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.audioGetSingleTrackKml(audioId, accept, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.audioGetSingleTrackKml']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Upload audio with optional track file
         * @summary Upload Audio
         * @param {string} [accept] 
         * @param {string} [contentType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async audioUpload(accept?: string, contentType?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.audioUpload(accept, contentType, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.audioUpload']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get All Audit Logs
         * @param {string} [source] Valid options include: &#x60;export&#x60;, &#x60;data_export&#x60;, &#x60;membership&#x60;, &#x60;layer&#x60;, &#x60;project&#x60;, &#x60;audit_log&#x60;, &#x60;role&#x60;, &#x60;form&#x60;, &#x60;data_share&#x60;, &#x60;classification_set&#x60;, &#x60;authorization&#x60;, &#x60;choice_list&#x60;, &#x60;import&#x60;, &#x60;organization&#x60;, &#x60;workflow&#x60;, &#x60;webhook&#x60;
         * @param {string} [activity] The available actions vary by log type but a complete list of valid actions includes: &#x60;update&#x60;, &#x60;create&#x60;, &#x60;permission_update&#x60;, &#x60;download&#x60;, &#x60;delete&#x60;, &#x60;reset&#x60;, &#x60;share_enabled&#x60;, &#x60;share_disabled&#x60;, &#x60;update_credit_card&#x60;, &#x60;plan_change&#x60;, &#x60;billing_emails_change&#x60;, &#x60;update_storage&#x60;, &#x60;add_credit&#x60;, &#x60;change_default&#x60;.
         * @param {string} [ip] Filter by ip address of the of the audit log action. The ip address must be an exact match in order to return in values from this filter.
         * @param {string} [user] Filter by user responsible for the logged changes. This parameter must be the Fulcrum resource id for the user in question, which can be obtained from the membership API.
         * @param {string} [updatedSince] Returns log entries since the given unix timestamp.
         * @param {string} [updatedBefore] Returns log entries before the given unix timestamp.
         * @param {number} [page] The page number requested
         * @param {number} [perPage] Number of items per page
         * @param {string} [accept] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async auditLogsGetAll(source?: string, activity?: string, ip?: string, user?: string, updatedSince?: string, updatedBefore?: string, page?: number, perPage?: number, accept?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.auditLogsGetAll(source, activity, ip, user, updatedSince, updatedBefore, page, perPage, accept, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.auditLogsGetAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Single Audit Log
         * @param {string} auditLogId Audit Log ID
         * @param {string} [accept] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async auditLogsGetSingle(auditLogId: string, accept?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.auditLogsGetSingle(auditLogId, accept, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.auditLogsGetSingle']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create Authorization
         * @param {string} [accept] 
         * @param {string} [contentType] 
         * @param {AuthorizationsCreateRequest} [authorizationsCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authorizationsCreate(accept?: string, contentType?: string, authorizationsCreateRequest?: AuthorizationsCreateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authorizationsCreate(accept, contentType, authorizationsCreateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.authorizationsCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete Authorization
         * @param {string} authorizationId Authorization ID
         * @param {string} [accept] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authorizationsDelete(authorizationId: string, accept?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authorizationsDelete(authorizationId, accept, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.authorizationsDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get All Authorizations
         * @param {number} [page] The page number requested
         * @param {number} [perPage] Number of items per page
         * @param {string} [accept] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authorizationsGetAll(page?: number, perPage?: number, accept?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authorizationsGetAll(page, perPage, accept, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.authorizationsGetAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Single Authorization
         * @param {string} authorizationId Authorization ID
         * @param {string} [accept] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authorizationsGetSingle(authorizationId: string, accept?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authorizationsGetSingle(authorizationId, accept, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.authorizationsGetSingle']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update Authorization
         * @param {string} authorizationId Authorization ID
         * @param {string} [accept] 
         * @param {string} [contentType] 
         * @param {AuthorizationsUpdateRequest} [authorizationsUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authorizationsUpdate(authorizationId: string, accept?: string, contentType?: string, authorizationsUpdateRequest?: AuthorizationsUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authorizationsUpdate(authorizationId, accept, contentType, authorizationsUpdateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.authorizationsUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Close Changeset
         * @param {string} changesetId Changeset ID
         * @param {string} [accept] 
         * @param {string} [contentType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async changesetsClose(changesetId: string, accept?: string, contentType?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.changesetsClose(changesetId, accept, contentType, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.changesetsClose']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create Changeset
         * @param {string} [accept] 
         * @param {string} [contentType] 
         * @param {ChangesetsCreateRequest} [changesetsCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async changesetsCreate(accept?: string, contentType?: string, changesetsCreateRequest?: ChangesetsCreateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.changesetsCreate(accept, contentType, changesetsCreateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.changesetsCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get All Changesets
         * @param {number} [page] The page number requested
         * @param {number} [perPage] Number of items per page
         * @param {string} [accept] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async changesetsGetAll(page?: number, perPage?: number, accept?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.changesetsGetAll(page, perPage, accept, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.changesetsGetAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Single Changeset
         * @param {string} changesetId Changeset ID
         * @param {string} [accept] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async changesetsGetSingle(changesetId: string, accept?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.changesetsGetSingle(changesetId, accept, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.changesetsGetSingle']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update Changeset
         * @param {string} changesetId Changeset ID
         * @param {string} [accept] 
         * @param {string} [contentType] 
         * @param {ChangesetsUpdateRequest} [changesetsUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async changesetsUpdate(changesetId: string, accept?: string, contentType?: string, changesetsUpdateRequest?: ChangesetsUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.changesetsUpdate(changesetId, accept, contentType, changesetsUpdateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.changesetsUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create Choice List
         * @param {string} [accept] 
         * @param {string} [contentType] 
         * @param {ChoiceListsCreateRequest} [choiceListsCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async choiceListsCreate(accept?: string, contentType?: string, choiceListsCreateRequest?: ChoiceListsCreateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.choiceListsCreate(accept, contentType, choiceListsCreateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.choiceListsCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete Choice List
         * @param {string} choiceListId Choice List ID
         * @param {string} [accept] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async choiceListsDelete(choiceListId: string, accept?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.choiceListsDelete(choiceListId, accept, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.choiceListsDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get All Choice Lists
         * @param {number} [page] The page number requested
         * @param {number} [perPage] Number of items per page
         * @param {string} [accept] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async choiceListsGetAll(page?: number, perPage?: number, accept?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.choiceListsGetAll(page, perPage, accept, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.choiceListsGetAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Single Choice List
         * @param {string} choiceListId Choice List ID
         * @param {string} [accept] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async choiceListsGetSingle(choiceListId: string, accept?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.choiceListsGetSingle(choiceListId, accept, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.choiceListsGetSingle']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update Choice List
         * @param {string} choiceListId Choice List ID
         * @param {string} [accept] 
         * @param {string} [contentType] 
         * @param {ChoiceListsUpdateRequest} [choiceListsUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async choiceListsUpdate(choiceListId: string, accept?: string, contentType?: string, choiceListsUpdateRequest?: ChoiceListsUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.choiceListsUpdate(choiceListId, accept, contentType, choiceListsUpdateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.choiceListsUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create Classification Set
         * @param {string} [accept] 
         * @param {string} [contentType] 
         * @param {ClassificationSetsCreateRequest} [classificationSetsCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async classificationSetsCreate(accept?: string, contentType?: string, classificationSetsCreateRequest?: ClassificationSetsCreateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.classificationSetsCreate(accept, contentType, classificationSetsCreateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.classificationSetsCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete Classification Set
         * @param {string} classificationSetId Classification Set ID
         * @param {string} [accept] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async classificationSetsDelete(classificationSetId: string, accept?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.classificationSetsDelete(classificationSetId, accept, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.classificationSetsDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get All Classification Sets
         * @param {number} [page] The page number requested
         * @param {number} [perPage] Number of items per page
         * @param {string} [accept] 
         * @param {ClassificationSetsGetAllTypeEnum} [type] Type of classification sets to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async classificationSetsGetAll(page?: number, perPage?: number, accept?: string, type?: ClassificationSetsGetAllTypeEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.classificationSetsGetAll(page, perPage, accept, type, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.classificationSetsGetAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Single Classification Set
         * @param {string} classificationSetId Classification Set ID
         * @param {string} [accept] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async classificationSetsGetSingle(classificationSetId: string, accept?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.classificationSetsGetSingle(classificationSetId, accept, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.classificationSetsGetSingle']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update Classification Set
         * @param {string} classificationSetId Classification Set ID
         * @param {string} [accept] 
         * @param {string} [contentType] 
         * @param {ClassificationSetsUpdateRequest} [classificationSetsUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async classificationSetsUpdate(classificationSetId: string, accept?: string, contentType?: string, classificationSetsUpdateRequest?: ClassificationSetsUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.classificationSetsUpdate(classificationSetId, accept, contentType, classificationSetsUpdateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.classificationSetsUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * There is only one parameter that is required for creating an attachment: `owners`. You must specify at least one owner of type `record` or `form`. If you create a `record` attachment you can optionally include a `name` and `file_size`. The name will be the name of the file shown in the record information. The file_size is only used for verifying that uploading this attachment will not exceed your current storage limit. If no file_size is provided the attachment may be rejected once it has been uploaded. The response will provide the `url` to upload (PUT) the file to.
         * @summary Create Attachment
         * @param {string} [xApitoken] API Token. Required to authenticate the request.
         * @param {CreateAttachmentRequest} [createAttachmentRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAttachment(xApitoken?: string, createAttachmentRequest?: CreateAttachmentRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateAttachment200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createAttachment(xApitoken, createAttachmentRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.createAttachment']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Using the batch operations API, you can bulk delete records from a form.
         * @summary Create Batch to Bulk Delete Records
         * @param {CreateBatchRequest} [createBatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createBatch(createBatchRequest?: CreateBatchRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createBatch(createBatchRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.createBatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create Group
         * @param {string} [accept] 
         * @param {string} [contentType] 
         * @param {CreateGroupRequest} [createGroupRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createGroup(accept?: string, contentType?: string, createGroupRequest?: CreateGroupRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateGroup201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createGroup(accept, contentType, createGroupRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.createGroup']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create Member
         * @param {string} [accept] 
         * @param {string} [contentType] 
         * @param {CreateMemberRequest} [createMemberRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createMember(accept?: string, contentType?: string, createMemberRequest?: CreateMemberRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createMember(accept, contentType, createMemberRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.createMember']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create Report Template
         * @param {CreateReportTemplateRequest} [createReportTemplateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createReportTemplate(createReportTemplateRequest?: CreateReportTemplateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createReportTemplate(createReportTemplateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.createReportTemplate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create Workflow
         * @param {string} [accept] 
         * @param {string} [contentTyoe] 
         * @param {CreateWorkflowRequest} [createWorkflowRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createWorkflow(accept?: string, contentTyoe?: string, createWorkflowRequest?: CreateWorkflowRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createWorkflow(accept, contentTyoe, createWorkflowRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.createWorkflow']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * The delete endpoint only applies to Form attachments. Use this endpoint to delete an attachment. For record attachments, simply remove the association of an attachment from the record and the attachment will be deleted.
         * @summary Delete Attachment
         * @param {string} attachmentId The attachment\&#39;s ID
         * @param {string} [xApitoken] API Token. Required to authenticate the request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAttachment(attachmentId: string, xApitoken?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAttachment(attachmentId, xApitoken, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.deleteAttachment']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete Group
         * @param {string} groupId ID of the group
         * @param {string} [accept] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteGroup(groupId: string, accept?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteGroup(groupId, accept, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.deleteGroup']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete Member
         * @param {string} membershipId The ID of the member
         * @param {DeleteMemberRequest} [deleteMemberRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteMember(membershipId: string, deleteMemberRequest?: DeleteMemberRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteMember(membershipId, deleteMemberRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.deleteMember']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete Report Template
         * @param {string} id The id of the report
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteReportTemplate(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteReportTemplate(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.deleteReportTemplate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete Workflow
         * @param {string} workflowId The ID of the workflow
         * @param {string} [accept] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteWorkflow(workflowId: string, accept?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteWorkflow(workflowId, accept, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.deleteWorkflow']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * The finalize endpoint is a required step for Form attachments. Use this endpoint to tell Fulcrum that your attachment has been uploaded.
         * @summary Finalize Attachment
         * @param {string} [xApitoken] API Token. Required to authenticate the request.
         * @param {FinalizeAttachmentRequest} [finalizeAttachmentRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async finalizeAttachment(xApitoken?: string, finalizeAttachmentRequest?: FinalizeAttachmentRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.finalizeAttachment(xApitoken, finalizeAttachmentRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.finalizeAttachment']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create Form
         * @param {string} [accept] 
         * @param {string} [contentType] 
         * @param {FormsCreateRequest} [formsCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async formsCreate(accept?: string, contentType?: string, formsCreateRequest?: FormsCreateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.formsCreate(accept, contentType, formsCreateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.formsCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete Form
         * @param {string} formId Form ID
         * @param {string} [accept] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async formsDelete(formId: string, accept?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.formsDelete(formId, accept, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.formsDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get All Forms
         * @param {boolean} [schema] schema&#x3D;false will only return the form metadata
         * @param {number} [page] The page number requested
         * @param {number} [perPage] Number of items per page
         * @param {string} [accept] 
         * @param {FormsGetAllTypeEnum} [type] Types of forms to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async formsGetAll(schema?: boolean, page?: number, perPage?: number, accept?: string, type?: FormsGetAllTypeEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.formsGetAll(schema, page, perPage, accept, type, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.formsGetAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Form History
         * @param {string} formId Form ID
         * @param {number} [version] The form history version
         * @param {number} [page] The page number requested
         * @param {number} [perPage] Number of items per page
         * @param {string} [accept] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async formsGetHistory(formId: string, version?: number, page?: number, perPage?: number, accept?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.formsGetHistory(formId, version, page, perPage, accept, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.formsGetHistory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Single Form
         * @param {string} formId Form ID
         * @param {string} [accept] 
         * @param {boolean} [schema] schema&#x3D;false will only return the form metadata
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async formsGetSingle(formId: string, accept?: string, schema?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.formsGetSingle(formId, accept, schema, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.formsGetSingle']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update Form
         * @param {string} formId Form ID
         * @param {string} [accept] 
         * @param {string} [contentType] 
         * @param {FormsUpdateRequest} [formsUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async formsUpdate(formId: string, accept?: string, contentType?: string, formsUpdateRequest?: FormsUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.formsUpdate(formId, accept, contentType, formsUpdateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.formsUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get All Attachments
         * @param {string} [recordId] The ID of the record with which the attachment is associated. This is required when listing record attachments.
         * @param {string} [formId] The ID of the form with which the attachment is associated. This parameter will allow you to get all reference files within a form, NOT all of the record attachments in a form
         * @param {string} [ownerType] The type of attachment to query for. Must be either &#x60;form&#x60; or &#x60;record&#x60;.
         * @param {string} [xApitoken] API Token. Required to authenticate the request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllAttachments(recordId?: string, formId?: string, ownerType?: string, xApitoken?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetAllAttachments200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllAttachments(recordId, formId, ownerType, xApitoken, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getAllAttachments']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get All Batches
         * @param {string} [page] 
         * @param {string} [perPage] 
         * @param {string} [sort] 
         * @param {string} [sortDirection] One of DESC for descending or ASC for ascending
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllBatches(page?: string, perPage?: string, sort?: string, sortDirection?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllBatches(page, perPage, sort, sortDirection, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getAllBatches']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get All Groups
         * @param {string} [page] 
         * @param {string} [perPage] 
         * @param {boolean} [associations] Set to &#x60;true&#x60; in order to see each group\&#39;s assigned &#x60;member_ids&#x60;, &#x60;layer_ids&#x60;, &#x60;project_ids&#x60; and &#x60;form_ids&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllGroups(page?: string, perPage?: string, associations?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllGroups(page, perPage, associations, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getAllGroups']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Membership Permissions
         * @param {string} type The type of permission (member_forms, member_layers, member_projects, form_members, layer_members, or project_members)
         * @param {string} objectId The membership_id of the user or the id of the form, layer or project
         * @param {number} [page] The page number requested
         * @param {number} [perPage] Number of items per page
         * @param {string} [accept] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllMemberships(type: string, objectId: string, page?: number, perPage?: number, accept?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllMemberships(type, objectId, page, perPage, accept, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getAllMemberships']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get All Report Templates
         * @param {number} [page] The page number requested
         * @param {number} [perPage] Number of items per page
         * @param {string} [formId] The form to fetch reports for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllReportTemplates(page?: number, perPage?: number, formId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllReportTemplates(page, perPage, formId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getAllReportTemplates']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get All Workflows
         * @param {number} [page] The page number requested
         * @param {number} [perPage] Number of items per page
         * @param {string} [accept] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllWorkflows(page?: number, perPage?: number, accept?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllWorkflows(page, perPage, accept, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getAllWorkflows']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Group Resource
         * @param {string} groupId Group ID
         * @param {string} resource One of &#x60;members&#x60;, &#x60;projects&#x60;, &#x60;layers&#x60; or &#x60;forms&#x60;
         * @param {string} [accept] 
         * @param {number} [page] Page of the response
         * @param {number} [perPage] Amount of items in every page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGroupResource(groupId: string, resource: string, accept?: string, page?: number, perPage?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGroupResource(groupId, resource, accept, page, perPage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getGroupResource']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Single Attachment
         * @param {string} attachmentId The attachment id.
         * @param {string} [xApitoken] API Token. Required to authenticate the request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSingleAttachment(attachmentId: string, xApitoken?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetSingleAttachment200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSingleAttachment(attachmentId, xApitoken, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getSingleAttachment']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Single Batch
         * @param {string} batchId The ID of the batch
         * @param {string} [page] 
         * @param {string} [perPage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSingleBatch(batchId: string, page?: string, perPage?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSingleBatch(batchId, page, perPage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getSingleBatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Single Group
         * @param {string} groupId Group ID
         * @param {string} [accept] 
         * @param {boolean} [associations] Set to &#x60;true&#x60; in order to see each group\&#39;s assigned &#x60;member_ids&#x60;, &#x60;layer_ids&#x60;, &#x60;project_ids&#x60; and &#x60;form_ids&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSingleGroup(groupId: string, accept?: string, associations?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSingleGroup(groupId, accept, associations, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getSingleGroup']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Single Report Template
         * @param {string} id The id of the report
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSingleReportTemplate(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSingleReportTemplate(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getSingleReportTemplate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Single Workflow
         * @param {string} workflowId The id of the workflow
         * @param {string} [accept] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSingleWorkflow(workflowId: string, accept?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSingleWorkflow(workflowId, accept, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getSingleWorkflow']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create Layer
         * @param {string} [accept] 
         * @param {string} [contentType] 
         * @param {LayersCreateRequest} [layersCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async layersCreate(accept?: string, contentType?: string, layersCreateRequest?: LayersCreateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.layersCreate(accept, contentType, layersCreateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.layersCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete Layer
         * @param {string} layerId Layer ID
         * @param {string} [accept] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async layersDelete(layerId: string, accept?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.layersDelete(layerId, accept, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.layersDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get All Layers
         * @param {number} [page] The page number requested
         * @param {number} [perPage] Number of items per page
         * @param {string} [accept] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async layersGetAll(page?: number, perPage?: number, accept?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.layersGetAll(page, perPage, accept, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.layersGetAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Single Layer
         * @param {string} layerId Layer ID
         * @param {string} [accept] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async layersGetSingle(layerId: string, accept?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.layersGetSingle(layerId, accept, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.layersGetSingle']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update Layer
         * @param {string} layerId Layer ID
         * @param {string} [accept] 
         * @param {string} [contentType] 
         * @param {LayersUpdateRequest} [layersUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async layersUpdate(layerId: string, accept?: string, contentType?: string, layersUpdateRequest?: LayersUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.layersUpdate(layerId, accept, contentType, layersUpdateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.layersUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Add or remove membership permissions from layers, forms, or projects
         * @summary Change Permissions
         * @param {string} [accept] 
         * @param {string} [contentType] 
         * @param {MembershipsChangePermissionsRequest} [membershipsChangePermissionsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async membershipsChangePermissions(accept?: string, contentType?: string, membershipsChangePermissionsRequest?: MembershipsChangePermissionsRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.membershipsChangePermissions(accept, contentType, membershipsChangePermissionsRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.membershipsChangePermissions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get All Memberships
         * @param {string} [formId] Limit members to a specific Form
         * @param {string} [projectId] Limit members to a specific Project
         * @param {string} [layerId] Limit members to a specific Layer
         * @param {number} [page] The page number requested
         * @param {number} [perPage] Number of items per page
         * @param {string} [accept] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async membershipsGetAll(formId?: string, projectId?: string, layerId?: string, page?: number, perPage?: number, accept?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.membershipsGetAll(formId, projectId, layerId, page, perPage, accept, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.membershipsGetAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Single Membership
         * @param {string} membershipId Membership ID
         * @param {string} [accept] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async membershipsGetSingle(membershipId: string, accept?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.membershipsGetSingle(membershipId, accept, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.membershipsGetSingle']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get All Photos
         * @param {string} [recordId] The ID of the record with which the photo is associated.
         * @param {string} [formId] The ID of the form with which the photo is associated. Leaving this blank will query against all of your photos.
         * @param {boolean} [newestFirst] If present, photos will be sorted by updated_at date.
         * @param {boolean} [processed] Photo has been completely processed.
         * @param {boolean} [stored] Photo has been completely stored.
         * @param {boolean} [uploaded] Photo has been completely uploaded.
         * @param {number} [page] The page number requested
         * @param {number} [perPage] Number of items per page
         * @param {string} [accept] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async photosGetAllMetadata(recordId?: string, formId?: string, newestFirst?: boolean, processed?: boolean, stored?: boolean, uploaded?: boolean, page?: number, perPage?: number, accept?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.photosGetAllMetadata(recordId, formId, newestFirst, processed, stored, uploaded, page, perPage, accept, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.photosGetAllMetadata']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Single Photo File
         * @param {string} photoId Photo ID
         * @param {string} [accept] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async photosGetSingleFile(photoId: string, accept?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.photosGetSingleFile(photoId, accept, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.photosGetSingleFile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Single Photo Metadata
         * @param {string} photoId Photo ID
         * @param {string} [accept] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async photosGetSingleMetadata(photoId: string, accept?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.photosGetSingleMetadata(photoId, accept, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.photosGetSingleMetadata']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Photo Large File
         * @param {string} photoId Photo ID
         * @param {string} [accept] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async photosLargeFile(photoId: string, accept?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.photosLargeFile(photoId, accept, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.photosLargeFile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Photo Large Metadata
         * @param {string} photoId Photo ID
         * @param {string} [accept] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async photosLargeMetadata(photoId: string, accept?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.photosLargeMetadata(photoId, accept, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.photosLargeMetadata']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Photo Thumbnail File
         * @param {string} photoId Photo ID
         * @param {string} [accept] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async photosThumbnailFile(photoId: string, accept?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.photosThumbnailFile(photoId, accept, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.photosThumbnailFile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Photo Thumbnail Metadata
         * @param {string} photoId Photo ID
         * @param {string} [accept] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async photosThumbnailMetadata(photoId: string, accept?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.photosThumbnailMetadata(photoId, accept, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.photosThumbnailMetadata']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Upload Photo
         * @param {string} [accept] 
         * @param {string} [contentType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async photosUpload(accept?: string, contentType?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.photosUpload(accept, contentType, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.photosUpload']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create Project
         * @param {string} [accept] 
         * @param {string} [contentType] 
         * @param {ProjectsCreateRequest} [projectsCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectsCreate(accept?: string, contentType?: string, projectsCreateRequest?: ProjectsCreateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectsCreate(accept, contentType, projectsCreateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.projectsCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete Project
         * @param {string} projectId Project ID
         * @param {string} [accept] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectsDelete(projectId: string, accept?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectsDelete(projectId, accept, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.projectsDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get All Projects
         * @param {number} [page] The page number requested
         * @param {number} [perPage] Number of items per page
         * @param {string} [accept] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectsGetAll(page?: number, perPage?: number, accept?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectsGetAll(page, perPage, accept, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.projectsGetAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Single Project
         * @param {string} projectId Project ID
         * @param {string} [accept] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectsGetSingle(projectId: string, accept?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectsGetSingle(projectId, accept, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.projectsGetSingle']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update Project
         * @param {string} projectId Project ID
         * @param {string} [accept] 
         * @param {string} [contentType] 
         * @param {ProjectsUpdateRequest} [projectsUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectsUpdate(projectId: string, accept?: string, contentType?: string, projectsUpdateRequest?: ProjectsUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectsUpdate(projectId, accept, contentType, projectsUpdateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.projectsUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary GET Query
         * @param {string} q The SQL query
         * @param {string} [format] The format of the results returned by the query. Options include &#x60;csv&#x60;, &#x60;json&#x60;, &#x60;geojson&#x60;, &#x60;postgres&#x60;.
         * @param {boolean} [headers] Include headers for csv format?
         * @param {boolean} [metadata] Include column metadata for &#x60;json&#x60; format?
         * @param {boolean} [arrays] Return row arrays instead of objects for &#x60;json&#x60; format?
         * @param {string} [tableName] Table name for &#x60;postgres&#x60; format. Defaults to query.
         * @param {string} [sortColumn] The name of the column used to sort on.
         * @param {string} [sortDirection] The sort direction (asc, desc).
         * @param {number} [page] The page number requested
         * @param {number} [perPage] Number of items per page
         * @param {string} [accept] 
         * @param {string} [userAgent] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async queryGet(q: string, format?: string, headers?: boolean, metadata?: boolean, arrays?: boolean, tableName?: string, sortColumn?: string, sortDirection?: string, page?: number, perPage?: number, accept?: string, userAgent?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.queryGet(q, format, headers, metadata, arrays, tableName, sortColumn, sortDirection, page, perPage, accept, userAgent, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.queryGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary POST Query
         * @param {number} [page] The page number requested
         * @param {number} [perPage] Number of items per page
         * @param {string} [accept] 
         * @param {QueryPostRequest} [queryPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async queryPost(page?: number, perPage?: number, accept?: string, queryPostRequest?: QueryPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.queryPost(page, perPage, accept, queryPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.queryPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create Record
         * @param {string} [accept] 
         * @param {string} [contentType] 
         * @param {boolean} [xSkipWorkflows] Skips all app workflows
         * @param {boolean} [xSkipWebhooks] Skips all app webhooks
         * @param {RecordsCreateRequest} [recordsCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async recordsCreate(accept?: string, contentType?: string, xSkipWorkflows?: boolean, xSkipWebhooks?: boolean, recordsCreateRequest?: RecordsCreateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.recordsCreate(accept, contentType, xSkipWorkflows, xSkipWebhooks, recordsCreateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.recordsCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete Record
         * @param {string} recordId Record ID
         * @param {string} [accept] 
         * @param {boolean} [xSkipWorkflows] Skips all app workflows
         * @param {boolean} [xSkipWebhooks] Skips all app webhooks
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async recordsDelete(recordId: string, accept?: string, xSkipWorkflows?: boolean, xSkipWebhooks?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.recordsDelete(recordId, accept, xSkipWorkflows, xSkipWebhooks, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.recordsDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get All Records
         * @param {boolean} [newestFirst] If present, records will be sorted by updated_at date.
         * @param {string} [boundingBox] Bounding box of the records requested. Format should be: lat,long,lat,long (bottom, left, top, right).
         * @param {string} [changesetId] The id of the changeset associated with the record.
         * @param {string} [formId] The id of the form with which the record is associated. Leaving this blank will query against all of your records.
         * @param {string} [projectId] The id of the project with which the record is associated. Leaving this blank will query against all of your records.
         * @param {string} [clientCreatedBefore] Return only records which were created by the client (device) before the given time.
         * @param {string} [clientCreatedSince] Return only records which were created by the client (device) after the given time.
         * @param {string} [clientUpdatedBefore] Return only records which were updated by the client (device) before the given time.
         * @param {string} [clientUpdatedSince] Return only records which were updated by the client (device) after the given time.
         * @param {string} [createdBefore] Return only records which were created (on the server) before the given time.
         * @param {string} [createdSince] Return only records which were created (on the server) after the given time.
         * @param {string} [updatedBefore] Return only records which were updated (on the server) before the given time.
         * @param {string} [updatedSince] Return only records which were updated (on the server) after the given time.
         * @param {number} [page] The page number requested
         * @param {number} [perPage] Number of items per page
         * @param {string} [accept] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async recordsGetAll(newestFirst?: boolean, boundingBox?: string, changesetId?: string, formId?: string, projectId?: string, clientCreatedBefore?: string, clientCreatedSince?: string, clientUpdatedBefore?: string, clientUpdatedSince?: string, createdBefore?: string, createdSince?: string, updatedBefore?: string, updatedSince?: string, page?: number, perPage?: number, accept?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RecordsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.recordsGetAll(newestFirst, boundingBox, changesetId, formId, projectId, clientCreatedBefore, clientCreatedSince, clientUpdatedBefore, clientUpdatedSince, createdBefore, createdSince, updatedBefore, updatedSince, page, perPage, accept, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.recordsGetAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This endpoint can help you get records from a specific changeset, or retrieve records for a deleted form.
         * @summary Get All Records History
         * @param {string} [accept] 
         * @param {string} [changesetId] 
         * @param {string} [deletedFormId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async recordsGetAllHistory(accept?: string, changesetId?: string, deletedFormId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.recordsGetAllHistory(accept, changesetId, deletedFormId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.recordsGetAllHistory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Record History
         * @param {string} recordId Record ID
         * @param {string} [accept] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async recordsGetHistory(recordId: string, accept?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.recordsGetHistory(recordId, accept, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.recordsGetHistory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Single Record
         * @param {string} recordId Record ID
         * @param {string} [accept] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async recordsGetSingle(recordId: string, accept?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ModelRecord>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.recordsGetSingle(recordId, accept, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.recordsGetSingle']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update Record
         * @param {string} recordId Record ID
         * @param {string} [accept] 
         * @param {string} [contentType] 
         * @param {boolean} [xSkipWorkflows] Skips all app workflows
         * @param {boolean} [xSkipWebhooks] Skips all app webhooks
         * @param {RecordsUpdateRequest} [recordsUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async recordsUpdate(recordId: string, accept?: string, contentType?: string, xSkipWorkflows?: boolean, xSkipWebhooks?: boolean, recordsUpdateRequest?: RecordsUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.recordsUpdate(recordId, accept, contentType, xSkipWorkflows, xSkipWebhooks, recordsUpdateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.recordsUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get All Roles
         * @param {number} [page] The page number requested
         * @param {number} [perPage] Number of items per page
         * @param {string} [accept] 
         * @param {string} [sort] Sort by role name. Default sort is by &#x60;updated_at&#x60; if sort is not provided
         * @param {string} [sortDirection] The sort direction (asc, desc). Default is &#x60;asc&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rolesGetAll(page?: number, perPage?: number, accept?: string, sort?: string, sortDirection?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rolesGetAll(page, perPage, accept, sort, sortDirection, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.rolesGetAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get All Signatures
         * @param {string} [recordId] The ID of the record with which the photo is associated.
         * @param {string} [formId] The ID of the form with which the photo is associated. Leaving this blank will query against all of your photos.
         * @param {boolean} [newestFirst] If present, photos will be sorted by updated_at date.
         * @param {boolean} [processed] Signature has been completely processed.
         * @param {boolean} [stored] Signature has been completely stored.
         * @param {boolean} [uploaded] Signature has been completely uploaded.
         * @param {number} [page] The page number requested
         * @param {number} [perPage] Number of items per page
         * @param {string} [accept] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async signaturesGetAll(recordId?: string, formId?: string, newestFirst?: boolean, processed?: boolean, stored?: boolean, uploaded?: boolean, page?: number, perPage?: number, accept?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.signaturesGetAll(recordId, formId, newestFirst, processed, stored, uploaded, page, perPage, accept, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.signaturesGetAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Single Signature File
         * @param {string} signatureId Signature ID
         * @param {string} [accept] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async signaturesGetSingleFile(signatureId: string, accept?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.signaturesGetSingleFile(signatureId, accept, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.signaturesGetSingleFile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Single Signature Metadata
         * @param {string} signatureId Signature ID
         * @param {string} [accept] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async signaturesGetSingleMetadata(signatureId: string, accept?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.signaturesGetSingleMetadata(signatureId, accept, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.signaturesGetSingleMetadata']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Signature Thumbnail File
         * @param {string} signatureId Signature ID
         * @param {string} [accept] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async signaturesGetThumbnailFile(signatureId: string, accept?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.signaturesGetThumbnailFile(signatureId, accept, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.signaturesGetThumbnailFile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Signature Thumbnail Metadata
         * @param {string} signatureId Signature ID
         * @param {string} [accept] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async signaturesGetThumbnailMetadata(signatureId: string, accept?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.signaturesGetThumbnailMetadata(signatureId, accept, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.signaturesGetThumbnailMetadata']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Upload Signature
         * @param {string} [accept] 
         * @param {string} [contentType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async signaturesUpload(accept?: string, contentType?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.signaturesUpload(accept, contentType, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.signaturesUpload']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Start your pending batch
         * @summary Start Batch
         * @param {string} batchId ID of the batch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async startBatch(batchId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.startBatch(batchId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.startBatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update Group Name / Description
         * @param {string} groupId ID of the group
         * @param {string} [accept] 
         * @param {string} [contentType] 
         * @param {UpdateGroupNameDescriptionRequest} [updateGroupNameDescriptionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateGroupNameDescription(groupId: string, accept?: string, contentType?: string, updateGroupNameDescriptionRequest?: UpdateGroupNameDescriptionRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateGroup201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateGroupNameDescription(groupId, accept, contentType, updateGroupNameDescriptionRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.updateGroupNameDescription']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update Group Permissions
         * @param {string} [accept] 
         * @param {string} [contentType] 
         * @param {UpdateGroupPermissionsRequest} [updateGroupPermissionsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateGroupPermissions(accept?: string, contentType?: string, updateGroupPermissionsRequest?: UpdateGroupPermissionsRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateGroup201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateGroupPermissions(accept, contentType, updateGroupPermissionsRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.updateGroupPermissions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * You can use this to update parameters of a member, but this will not work if the member is apart of multiple organizations.
         * @summary Update Member
         * @param {string} membershipId The ID of the member
         * @param {UpdateMemberRequest} [updateMemberRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateMember(membershipId: string, updateMemberRequest?: UpdateMemberRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateMember(membershipId, updateMemberRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.updateMember']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update Report Template
         * @param {string} id The id of the report
         * @param {UpdateReportTemplateRequest} [updateReportTemplateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateReportTemplate(id: string, updateReportTemplateRequest?: UpdateReportTemplateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateReportTemplate(id, updateReportTemplateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.updateReportTemplate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update Workflow
         * @param {string} workflowId The ID of the workflow
         * @param {string} [accept] 
         * @param {string} [contentTyoe] 
         * @param {UpdateWorkflowRequest} [updateWorkflowRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateWorkflow(workflowId: string, accept?: string, contentTyoe?: string, updateWorkflowRequest?: UpdateWorkflowRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateWorkflow(workflowId, accept, contentTyoe, updateWorkflowRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.updateWorkflow']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get User Information
         * @param {number} [page] The page number requested
         * @param {number} [perPage] Number of items per page
         * @param {string} [accept] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersGetUser(page?: number, perPage?: number, accept?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersGetUser(page, perPage, accept, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.usersGetUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get All Videos
         * @param {string} [recordId] The ID of the record with which the video is associated.
         * @param {string} [formId] The ID of the form with which the video is associated. Leaving this blank will query against all of your videos.
         * @param {boolean} [newestFirst] If present, videos will be sorted by updated_at date.
         * @param {boolean} [processed] Video has been completely processed.
         * @param {boolean} [stored] Video has been completely stored.
         * @param {boolean} [uploaded] Video has been completely uploaded.
         * @param {number} [page] The page number requested
         * @param {number} [perPage] Number of items per page
         * @param {string} [accept] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async videosGetAll(recordId?: string, formId?: string, newestFirst?: boolean, processed?: boolean, stored?: boolean, uploaded?: boolean, page?: number, perPage?: number, accept?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.videosGetAll(recordId, formId, newestFirst, processed, stored, uploaded, page, perPage, accept, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.videosGetAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get GeoJSON Tracks for All Videos
         * @param {string} [accept] 
         * @param {string} [type] Set value to &#x60;points&#x60; to fetch tracks as GeoJSON points
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async videosGetAllTracksGeojson(accept?: string, type?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.videosGetAllTracksGeojson(accept, type, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.videosGetAllTracksGeojson']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get GPX Tracks for All Videos
         * @param {string} [accept] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async videosGetAllTracksGpx(accept?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.videosGetAllTracksGpx(accept, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.videosGetAllTracksGpx']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get KML Tracks for All Videos
         * @param {string} [accept] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async videosGetAllTracksKml(accept?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.videosGetAllTracksKml(accept, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.videosGetAllTracksKml']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Medium Video File
         * @param {string} videoId Video ID
         * @param {string} [accept] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async videosGetMediumFile(videoId: string, accept?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.videosGetMediumFile(videoId, accept, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.videosGetMediumFile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Original Video File
         * @param {string} videoId Video ID
         * @param {string} [accept] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async videosGetOriginalFile(videoId: string, accept?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.videosGetOriginalFile(videoId, accept, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.videosGetOriginalFile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Video Metadata
         * @param {string} videoId Video ID
         * @param {string} [accept] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async videosGetSingleMetadata(videoId: string, accept?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.videosGetSingleMetadata(videoId, accept, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.videosGetSingleMetadata']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get GeoJSON Video Track
         * @param {string} videoId Video ID
         * @param {string} [accept] 
         * @param {string} [type] Set value to &#x60;points&#x60; to fetch tracks as GeoJSON points
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async videosGetSingleTrackGeojson(videoId: string, accept?: string, type?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.videosGetSingleTrackGeojson(videoId, accept, type, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.videosGetSingleTrackGeojson']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get GPX Video Track
         * @param {string} videoId Video ID
         * @param {string} [accept] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async videosGetSingleTrackGpx(videoId: string, accept?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.videosGetSingleTrackGpx(videoId, accept, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.videosGetSingleTrackGpx']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get JSON Video Track
         * @param {string} videoId Video ID
         * @param {string} [accept] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async videosGetSingleTrackJson(videoId: string, accept?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.videosGetSingleTrackJson(videoId, accept, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.videosGetSingleTrackJson']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get KML Video Track
         * @param {string} videoId Video ID
         * @param {string} [accept] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async videosGetSingleTrackKml(videoId: string, accept?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.videosGetSingleTrackKml(videoId, accept, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.videosGetSingleTrackKml']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Small Video File
         * @param {string} videoId Video ID
         * @param {string} [accept] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async videosGetSmallFile(videoId: string, accept?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.videosGetSmallFile(videoId, accept, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.videosGetSmallFile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Huge Video Thumbnail
         * @param {string} videoId Video ID
         * @param {string} [accept] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async videosGetThumbnailHuge(videoId: string, accept?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.videosGetThumbnailHuge(videoId, accept, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.videosGetThumbnailHuge']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Huge Square Video Thumbnail
         * @param {string} videoId Video ID
         * @param {string} [accept] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async videosGetThumbnailHugeSquare(videoId: string, accept?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.videosGetThumbnailHugeSquare(videoId, accept, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.videosGetThumbnailHugeSquare']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Large Video Thumbnail
         * @param {string} videoId Video ID
         * @param {string} [accept] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async videosGetThumbnailLarge(videoId: string, accept?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.videosGetThumbnailLarge(videoId, accept, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.videosGetThumbnailLarge']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Large Square Video Thumbnail
         * @param {string} videoId Video ID
         * @param {string} [accept] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async videosGetThumbnailLargeSquare(videoId: string, accept?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.videosGetThumbnailLargeSquare(videoId, accept, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.videosGetThumbnailLargeSquare']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Medium Video Thumbnail
         * @param {string} videoId Video ID
         * @param {string} [accept] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async videosGetThumbnailMedium(videoId: string, accept?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.videosGetThumbnailMedium(videoId, accept, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.videosGetThumbnailMedium']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Medium Square Video Thumbnail
         * @param {string} videoId Video ID
         * @param {string} [accept] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async videosGetThumbnailMediumSquare(videoId: string, accept?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.videosGetThumbnailMediumSquare(videoId, accept, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.videosGetThumbnailMediumSquare']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Small Video Thumbnail
         * @param {string} videoId Video ID
         * @param {string} [accept] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async videosGetThumbnailSmall(videoId: string, accept?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.videosGetThumbnailSmall(videoId, accept, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.videosGetThumbnailSmall']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Small Square Video Thumbnail
         * @param {string} videoId Video ID
         * @param {string} [accept] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async videosGetThumbnailSmallSquare(videoId: string, accept?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.videosGetThumbnailSmallSquare(videoId, accept, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.videosGetThumbnailSmallSquare']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Upload video with optional track file
         * @summary Upload Video
         * @param {string} [accept] 
         * @param {string} [contentType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async videosUpload(accept?: string, contentType?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.videosUpload(accept, contentType, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.videosUpload']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create Webhook
         * @param {string} [accept] 
         * @param {string} [contentType] 
         * @param {WebhooksCreateRequest} [webhooksCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async webhooksCreate(accept?: string, contentType?: string, webhooksCreateRequest?: WebhooksCreateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebhooksCreate201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.webhooksCreate(accept, contentType, webhooksCreateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.webhooksCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete Webhook
         * @param {string} webhookId Webhook ID
         * @param {string} [accept] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async webhooksDelete(webhookId: string, accept?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.webhooksDelete(webhookId, accept, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.webhooksDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get All Webhooks
         * @param {number} [page] The page number requested
         * @param {number} [perPage] Number of items per page
         * @param {string} [accept] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async webhooksGetAll(page?: number, perPage?: number, accept?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebhooksGetAll200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.webhooksGetAll(page, perPage, accept, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.webhooksGetAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Single Webhook
         * @param {string} webhookId Webhook ID
         * @param {string} [accept] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async webhooksGetSingle(webhookId: string, accept?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.webhooksGetSingle(webhookId, accept, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.webhooksGetSingle']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update Webhook
         * @param {string} webhookId Webhook ID
         * @param {string} [accept] 
         * @param {string} [contentType] 
         * @param {WebhooksUpdateRequest} [webhooksUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async webhooksUpdate(webhookId: string, accept?: string, contentType?: string, webhooksUpdateRequest?: WebhooksUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.webhooksUpdate(webhookId, accept, contentType, webhooksUpdateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.webhooksUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DefaultApi - factory interface
 */
export const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DefaultApiFp(configuration)
    return {
        /**
         * Using the batch operations API, you can bulk delete records from a form or update project, assignee, or status values on multiple records.
         * @summary Add batch operations
         * @param {DefaultApiAddBatchOperationsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addBatchOperations(requestParameters: DefaultApiAddBatchOperationsRequest, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.addBatchOperations(requestParameters.batchId, requestParameters.addBatchOperationsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get All Audio
         * @param {DefaultApiAudioGetAllRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        audioGetAll(requestParameters: DefaultApiAudioGetAllRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.audioGetAll(requestParameters.recordId, requestParameters.formId, requestParameters.newestFirst, requestParameters.processed, requestParameters.stored, requestParameters.uploaded, requestParameters.page, requestParameters.perPage, requestParameters.accept, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get GeoJSON Tracks for All Audio
         * @param {DefaultApiAudioGetAllTracksGeojsonRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        audioGetAllTracksGeojson(requestParameters: DefaultApiAudioGetAllTracksGeojsonRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.audioGetAllTracksGeojson(requestParameters.accept, requestParameters.type, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get GPX Tracks for All Audio
         * @param {DefaultApiAudioGetAllTracksGpxRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        audioGetAllTracksGpx(requestParameters: DefaultApiAudioGetAllTracksGpxRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.audioGetAllTracksGpx(requestParameters.accept, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get JSON Tracks for All Audio
         * @param {DefaultApiAudioGetAllTracksJsonRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        audioGetAllTracksJson(requestParameters: DefaultApiAudioGetAllTracksJsonRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.audioGetAllTracksJson(requestParameters.accept, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get KML Tracks for All Audio
         * @param {DefaultApiAudioGetAllTracksKmlRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        audioGetAllTracksKml(requestParameters: DefaultApiAudioGetAllTracksKmlRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.audioGetAllTracksKml(requestParameters.accept, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Original Audio File
         * @param {DefaultApiAudioGetOriginalFileRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        audioGetOriginalFile(requestParameters: DefaultApiAudioGetOriginalFileRequest, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.audioGetOriginalFile(requestParameters.audioId, requestParameters.accept, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Audio Metadata
         * @param {DefaultApiAudioGetSingleMetadataRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        audioGetSingleMetadata(requestParameters: DefaultApiAudioGetSingleMetadataRequest, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.audioGetSingleMetadata(requestParameters.audioId, requestParameters.accept, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get GeoJSON Audio Track
         * @param {DefaultApiAudioGetSingleTrackGeojsonRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        audioGetSingleTrackGeojson(requestParameters: DefaultApiAudioGetSingleTrackGeojsonRequest, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.audioGetSingleTrackGeojson(requestParameters.audioId, requestParameters.accept, requestParameters.type, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get GPX Audio Track
         * @param {DefaultApiAudioGetSingleTrackGpxRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        audioGetSingleTrackGpx(requestParameters: DefaultApiAudioGetSingleTrackGpxRequest, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.audioGetSingleTrackGpx(requestParameters.audioId, requestParameters.accept, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get JSON Audio Track
         * @param {DefaultApiAudioGetSingleTrackJsonRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        audioGetSingleTrackJson(requestParameters: DefaultApiAudioGetSingleTrackJsonRequest, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.audioGetSingleTrackJson(requestParameters.audioId, requestParameters.accept, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get KML Audio Track
         * @param {DefaultApiAudioGetSingleTrackKmlRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        audioGetSingleTrackKml(requestParameters: DefaultApiAudioGetSingleTrackKmlRequest, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.audioGetSingleTrackKml(requestParameters.audioId, requestParameters.accept, options).then((request) => request(axios, basePath));
        },
        /**
         * Upload audio with optional track file
         * @summary Upload Audio
         * @param {DefaultApiAudioUploadRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        audioUpload(requestParameters: DefaultApiAudioUploadRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.audioUpload(requestParameters.accept, requestParameters.contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get All Audit Logs
         * @param {DefaultApiAuditLogsGetAllRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        auditLogsGetAll(requestParameters: DefaultApiAuditLogsGetAllRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.auditLogsGetAll(requestParameters.source, requestParameters.activity, requestParameters.ip, requestParameters.user, requestParameters.updatedSince, requestParameters.updatedBefore, requestParameters.page, requestParameters.perPage, requestParameters.accept, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Single Audit Log
         * @param {DefaultApiAuditLogsGetSingleRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        auditLogsGetSingle(requestParameters: DefaultApiAuditLogsGetSingleRequest, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.auditLogsGetSingle(requestParameters.auditLogId, requestParameters.accept, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create Authorization
         * @param {DefaultApiAuthorizationsCreateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authorizationsCreate(requestParameters: DefaultApiAuthorizationsCreateRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.authorizationsCreate(requestParameters.accept, requestParameters.contentType, requestParameters.authorizationsCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete Authorization
         * @param {DefaultApiAuthorizationsDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authorizationsDelete(requestParameters: DefaultApiAuthorizationsDeleteRequest, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.authorizationsDelete(requestParameters.authorizationId, requestParameters.accept, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get All Authorizations
         * @param {DefaultApiAuthorizationsGetAllRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authorizationsGetAll(requestParameters: DefaultApiAuthorizationsGetAllRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.authorizationsGetAll(requestParameters.page, requestParameters.perPage, requestParameters.accept, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Single Authorization
         * @param {DefaultApiAuthorizationsGetSingleRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authorizationsGetSingle(requestParameters: DefaultApiAuthorizationsGetSingleRequest, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.authorizationsGetSingle(requestParameters.authorizationId, requestParameters.accept, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update Authorization
         * @param {DefaultApiAuthorizationsUpdateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authorizationsUpdate(requestParameters: DefaultApiAuthorizationsUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.authorizationsUpdate(requestParameters.authorizationId, requestParameters.accept, requestParameters.contentType, requestParameters.authorizationsUpdateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Close Changeset
         * @param {DefaultApiChangesetsCloseRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changesetsClose(requestParameters: DefaultApiChangesetsCloseRequest, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.changesetsClose(requestParameters.changesetId, requestParameters.accept, requestParameters.contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create Changeset
         * @param {DefaultApiChangesetsCreateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changesetsCreate(requestParameters: DefaultApiChangesetsCreateRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.changesetsCreate(requestParameters.accept, requestParameters.contentType, requestParameters.changesetsCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get All Changesets
         * @param {DefaultApiChangesetsGetAllRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changesetsGetAll(requestParameters: DefaultApiChangesetsGetAllRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.changesetsGetAll(requestParameters.page, requestParameters.perPage, requestParameters.accept, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Single Changeset
         * @param {DefaultApiChangesetsGetSingleRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changesetsGetSingle(requestParameters: DefaultApiChangesetsGetSingleRequest, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.changesetsGetSingle(requestParameters.changesetId, requestParameters.accept, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update Changeset
         * @param {DefaultApiChangesetsUpdateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changesetsUpdate(requestParameters: DefaultApiChangesetsUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.changesetsUpdate(requestParameters.changesetId, requestParameters.accept, requestParameters.contentType, requestParameters.changesetsUpdateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create Choice List
         * @param {DefaultApiChoiceListsCreateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        choiceListsCreate(requestParameters: DefaultApiChoiceListsCreateRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.choiceListsCreate(requestParameters.accept, requestParameters.contentType, requestParameters.choiceListsCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete Choice List
         * @param {DefaultApiChoiceListsDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        choiceListsDelete(requestParameters: DefaultApiChoiceListsDeleteRequest, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.choiceListsDelete(requestParameters.choiceListId, requestParameters.accept, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get All Choice Lists
         * @param {DefaultApiChoiceListsGetAllRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        choiceListsGetAll(requestParameters: DefaultApiChoiceListsGetAllRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.choiceListsGetAll(requestParameters.page, requestParameters.perPage, requestParameters.accept, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Single Choice List
         * @param {DefaultApiChoiceListsGetSingleRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        choiceListsGetSingle(requestParameters: DefaultApiChoiceListsGetSingleRequest, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.choiceListsGetSingle(requestParameters.choiceListId, requestParameters.accept, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update Choice List
         * @param {DefaultApiChoiceListsUpdateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        choiceListsUpdate(requestParameters: DefaultApiChoiceListsUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.choiceListsUpdate(requestParameters.choiceListId, requestParameters.accept, requestParameters.contentType, requestParameters.choiceListsUpdateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create Classification Set
         * @param {DefaultApiClassificationSetsCreateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        classificationSetsCreate(requestParameters: DefaultApiClassificationSetsCreateRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.classificationSetsCreate(requestParameters.accept, requestParameters.contentType, requestParameters.classificationSetsCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete Classification Set
         * @param {DefaultApiClassificationSetsDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        classificationSetsDelete(requestParameters: DefaultApiClassificationSetsDeleteRequest, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.classificationSetsDelete(requestParameters.classificationSetId, requestParameters.accept, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get All Classification Sets
         * @param {DefaultApiClassificationSetsGetAllRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        classificationSetsGetAll(requestParameters: DefaultApiClassificationSetsGetAllRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.classificationSetsGetAll(requestParameters.page, requestParameters.perPage, requestParameters.accept, requestParameters.type, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Single Classification Set
         * @param {DefaultApiClassificationSetsGetSingleRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        classificationSetsGetSingle(requestParameters: DefaultApiClassificationSetsGetSingleRequest, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.classificationSetsGetSingle(requestParameters.classificationSetId, requestParameters.accept, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update Classification Set
         * @param {DefaultApiClassificationSetsUpdateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        classificationSetsUpdate(requestParameters: DefaultApiClassificationSetsUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.classificationSetsUpdate(requestParameters.classificationSetId, requestParameters.accept, requestParameters.contentType, requestParameters.classificationSetsUpdateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * There is only one parameter that is required for creating an attachment: `owners`. You must specify at least one owner of type `record` or `form`. If you create a `record` attachment you can optionally include a `name` and `file_size`. The name will be the name of the file shown in the record information. The file_size is only used for verifying that uploading this attachment will not exceed your current storage limit. If no file_size is provided the attachment may be rejected once it has been uploaded. The response will provide the `url` to upload (PUT) the file to.
         * @summary Create Attachment
         * @param {DefaultApiCreateAttachmentRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAttachment(requestParameters: DefaultApiCreateAttachmentRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<CreateAttachment200Response> {
            return localVarFp.createAttachment(requestParameters.xApitoken, requestParameters.createAttachmentRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Using the batch operations API, you can bulk delete records from a form.
         * @summary Create Batch to Bulk Delete Records
         * @param {DefaultApiCreateBatchRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBatch(requestParameters: DefaultApiCreateBatchRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.createBatch(requestParameters.createBatchRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create Group
         * @param {DefaultApiCreateGroupRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGroup(requestParameters: DefaultApiCreateGroupRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<CreateGroup201Response> {
            return localVarFp.createGroup(requestParameters.accept, requestParameters.contentType, requestParameters.createGroupRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create Member
         * @param {DefaultApiCreateMemberRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMember(requestParameters: DefaultApiCreateMemberRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.createMember(requestParameters.accept, requestParameters.contentType, requestParameters.createMemberRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create Report Template
         * @param {DefaultApiCreateReportTemplateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createReportTemplate(requestParameters: DefaultApiCreateReportTemplateRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.createReportTemplate(requestParameters.createReportTemplateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create Workflow
         * @param {DefaultApiCreateWorkflowRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWorkflow(requestParameters: DefaultApiCreateWorkflowRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.createWorkflow(requestParameters.accept, requestParameters.contentTyoe, requestParameters.createWorkflowRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * The delete endpoint only applies to Form attachments. Use this endpoint to delete an attachment. For record attachments, simply remove the association of an attachment from the record and the attachment will be deleted.
         * @summary Delete Attachment
         * @param {DefaultApiDeleteAttachmentRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAttachment(requestParameters: DefaultApiDeleteAttachmentRequest, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.deleteAttachment(requestParameters.attachmentId, requestParameters.xApitoken, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete Group
         * @param {DefaultApiDeleteGroupRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGroup(requestParameters: DefaultApiDeleteGroupRequest, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.deleteGroup(requestParameters.groupId, requestParameters.accept, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete Member
         * @param {DefaultApiDeleteMemberRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMember(requestParameters: DefaultApiDeleteMemberRequest, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.deleteMember(requestParameters.membershipId, requestParameters.deleteMemberRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete Report Template
         * @param {DefaultApiDeleteReportTemplateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteReportTemplate(requestParameters: DefaultApiDeleteReportTemplateRequest, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.deleteReportTemplate(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete Workflow
         * @param {DefaultApiDeleteWorkflowRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWorkflow(requestParameters: DefaultApiDeleteWorkflowRequest, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.deleteWorkflow(requestParameters.workflowId, requestParameters.accept, options).then((request) => request(axios, basePath));
        },
        /**
         * The finalize endpoint is a required step for Form attachments. Use this endpoint to tell Fulcrum that your attachment has been uploaded.
         * @summary Finalize Attachment
         * @param {DefaultApiFinalizeAttachmentRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        finalizeAttachment(requestParameters: DefaultApiFinalizeAttachmentRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.finalizeAttachment(requestParameters.xApitoken, requestParameters.finalizeAttachmentRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create Form
         * @param {DefaultApiFormsCreateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        formsCreate(requestParameters: DefaultApiFormsCreateRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.formsCreate(requestParameters.accept, requestParameters.contentType, requestParameters.formsCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete Form
         * @param {DefaultApiFormsDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        formsDelete(requestParameters: DefaultApiFormsDeleteRequest, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.formsDelete(requestParameters.formId, requestParameters.accept, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get All Forms
         * @param {DefaultApiFormsGetAllRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        formsGetAll(requestParameters: DefaultApiFormsGetAllRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.formsGetAll(requestParameters.schema, requestParameters.page, requestParameters.perPage, requestParameters.accept, requestParameters.type, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Form History
         * @param {DefaultApiFormsGetHistoryRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        formsGetHistory(requestParameters: DefaultApiFormsGetHistoryRequest, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.formsGetHistory(requestParameters.formId, requestParameters.version, requestParameters.page, requestParameters.perPage, requestParameters.accept, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Single Form
         * @param {DefaultApiFormsGetSingleRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        formsGetSingle(requestParameters: DefaultApiFormsGetSingleRequest, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.formsGetSingle(requestParameters.formId, requestParameters.accept, requestParameters.schema, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update Form
         * @param {DefaultApiFormsUpdateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        formsUpdate(requestParameters: DefaultApiFormsUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.formsUpdate(requestParameters.formId, requestParameters.accept, requestParameters.contentType, requestParameters.formsUpdateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get All Attachments
         * @param {DefaultApiGetAllAttachmentsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllAttachments(requestParameters: DefaultApiGetAllAttachmentsRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<GetAllAttachments200Response> {
            return localVarFp.getAllAttachments(requestParameters.recordId, requestParameters.formId, requestParameters.ownerType, requestParameters.xApitoken, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get All Batches
         * @param {DefaultApiGetAllBatchesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllBatches(requestParameters: DefaultApiGetAllBatchesRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.getAllBatches(requestParameters.page, requestParameters.perPage, requestParameters.sort, requestParameters.sortDirection, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get All Groups
         * @param {DefaultApiGetAllGroupsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllGroups(requestParameters: DefaultApiGetAllGroupsRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.getAllGroups(requestParameters.page, requestParameters.perPage, requestParameters.associations, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Membership Permissions
         * @param {DefaultApiGetAllMembershipsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllMemberships(requestParameters: DefaultApiGetAllMembershipsRequest, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.getAllMemberships(requestParameters.type, requestParameters.objectId, requestParameters.page, requestParameters.perPage, requestParameters.accept, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get All Report Templates
         * @param {DefaultApiGetAllReportTemplatesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllReportTemplates(requestParameters: DefaultApiGetAllReportTemplatesRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.getAllReportTemplates(requestParameters.page, requestParameters.perPage, requestParameters.formId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get All Workflows
         * @param {DefaultApiGetAllWorkflowsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllWorkflows(requestParameters: DefaultApiGetAllWorkflowsRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.getAllWorkflows(requestParameters.page, requestParameters.perPage, requestParameters.accept, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Group Resource
         * @param {DefaultApiGetGroupResourceRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupResource(requestParameters: DefaultApiGetGroupResourceRequest, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.getGroupResource(requestParameters.groupId, requestParameters.resource, requestParameters.accept, requestParameters.page, requestParameters.perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Single Attachment
         * @param {DefaultApiGetSingleAttachmentRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSingleAttachment(requestParameters: DefaultApiGetSingleAttachmentRequest, options?: RawAxiosRequestConfig): AxiosPromise<GetSingleAttachment200Response> {
            return localVarFp.getSingleAttachment(requestParameters.attachmentId, requestParameters.xApitoken, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Single Batch
         * @param {DefaultApiGetSingleBatchRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSingleBatch(requestParameters: DefaultApiGetSingleBatchRequest, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.getSingleBatch(requestParameters.batchId, requestParameters.page, requestParameters.perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Single Group
         * @param {DefaultApiGetSingleGroupRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSingleGroup(requestParameters: DefaultApiGetSingleGroupRequest, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.getSingleGroup(requestParameters.groupId, requestParameters.accept, requestParameters.associations, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Single Report Template
         * @param {DefaultApiGetSingleReportTemplateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSingleReportTemplate(requestParameters: DefaultApiGetSingleReportTemplateRequest, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.getSingleReportTemplate(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Single Workflow
         * @param {DefaultApiGetSingleWorkflowRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSingleWorkflow(requestParameters: DefaultApiGetSingleWorkflowRequest, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.getSingleWorkflow(requestParameters.workflowId, requestParameters.accept, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create Layer
         * @param {DefaultApiLayersCreateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        layersCreate(requestParameters: DefaultApiLayersCreateRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.layersCreate(requestParameters.accept, requestParameters.contentType, requestParameters.layersCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete Layer
         * @param {DefaultApiLayersDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        layersDelete(requestParameters: DefaultApiLayersDeleteRequest, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.layersDelete(requestParameters.layerId, requestParameters.accept, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get All Layers
         * @param {DefaultApiLayersGetAllRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        layersGetAll(requestParameters: DefaultApiLayersGetAllRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.layersGetAll(requestParameters.page, requestParameters.perPage, requestParameters.accept, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Single Layer
         * @param {DefaultApiLayersGetSingleRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        layersGetSingle(requestParameters: DefaultApiLayersGetSingleRequest, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.layersGetSingle(requestParameters.layerId, requestParameters.accept, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update Layer
         * @param {DefaultApiLayersUpdateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        layersUpdate(requestParameters: DefaultApiLayersUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.layersUpdate(requestParameters.layerId, requestParameters.accept, requestParameters.contentType, requestParameters.layersUpdateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Add or remove membership permissions from layers, forms, or projects
         * @summary Change Permissions
         * @param {DefaultApiMembershipsChangePermissionsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        membershipsChangePermissions(requestParameters: DefaultApiMembershipsChangePermissionsRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.membershipsChangePermissions(requestParameters.accept, requestParameters.contentType, requestParameters.membershipsChangePermissionsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get All Memberships
         * @param {DefaultApiMembershipsGetAllRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        membershipsGetAll(requestParameters: DefaultApiMembershipsGetAllRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.membershipsGetAll(requestParameters.formId, requestParameters.projectId, requestParameters.layerId, requestParameters.page, requestParameters.perPage, requestParameters.accept, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Single Membership
         * @param {DefaultApiMembershipsGetSingleRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        membershipsGetSingle(requestParameters: DefaultApiMembershipsGetSingleRequest, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.membershipsGetSingle(requestParameters.membershipId, requestParameters.accept, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get All Photos
         * @param {DefaultApiPhotosGetAllMetadataRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        photosGetAllMetadata(requestParameters: DefaultApiPhotosGetAllMetadataRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.photosGetAllMetadata(requestParameters.recordId, requestParameters.formId, requestParameters.newestFirst, requestParameters.processed, requestParameters.stored, requestParameters.uploaded, requestParameters.page, requestParameters.perPage, requestParameters.accept, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Single Photo File
         * @param {DefaultApiPhotosGetSingleFileRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        photosGetSingleFile(requestParameters: DefaultApiPhotosGetSingleFileRequest, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.photosGetSingleFile(requestParameters.photoId, requestParameters.accept, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Single Photo Metadata
         * @param {DefaultApiPhotosGetSingleMetadataRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        photosGetSingleMetadata(requestParameters: DefaultApiPhotosGetSingleMetadataRequest, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.photosGetSingleMetadata(requestParameters.photoId, requestParameters.accept, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Photo Large File
         * @param {DefaultApiPhotosLargeFileRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        photosLargeFile(requestParameters: DefaultApiPhotosLargeFileRequest, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.photosLargeFile(requestParameters.photoId, requestParameters.accept, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Photo Large Metadata
         * @param {DefaultApiPhotosLargeMetadataRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        photosLargeMetadata(requestParameters: DefaultApiPhotosLargeMetadataRequest, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.photosLargeMetadata(requestParameters.photoId, requestParameters.accept, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Photo Thumbnail File
         * @param {DefaultApiPhotosThumbnailFileRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        photosThumbnailFile(requestParameters: DefaultApiPhotosThumbnailFileRequest, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.photosThumbnailFile(requestParameters.photoId, requestParameters.accept, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Photo Thumbnail Metadata
         * @param {DefaultApiPhotosThumbnailMetadataRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        photosThumbnailMetadata(requestParameters: DefaultApiPhotosThumbnailMetadataRequest, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.photosThumbnailMetadata(requestParameters.photoId, requestParameters.accept, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Upload Photo
         * @param {DefaultApiPhotosUploadRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        photosUpload(requestParameters: DefaultApiPhotosUploadRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.photosUpload(requestParameters.accept, requestParameters.contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create Project
         * @param {DefaultApiProjectsCreateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsCreate(requestParameters: DefaultApiProjectsCreateRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.projectsCreate(requestParameters.accept, requestParameters.contentType, requestParameters.projectsCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete Project
         * @param {DefaultApiProjectsDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsDelete(requestParameters: DefaultApiProjectsDeleteRequest, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.projectsDelete(requestParameters.projectId, requestParameters.accept, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get All Projects
         * @param {DefaultApiProjectsGetAllRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsGetAll(requestParameters: DefaultApiProjectsGetAllRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.projectsGetAll(requestParameters.page, requestParameters.perPage, requestParameters.accept, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Single Project
         * @param {DefaultApiProjectsGetSingleRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsGetSingle(requestParameters: DefaultApiProjectsGetSingleRequest, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.projectsGetSingle(requestParameters.projectId, requestParameters.accept, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update Project
         * @param {DefaultApiProjectsUpdateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsUpdate(requestParameters: DefaultApiProjectsUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.projectsUpdate(requestParameters.projectId, requestParameters.accept, requestParameters.contentType, requestParameters.projectsUpdateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary GET Query
         * @param {DefaultApiQueryGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queryGet(requestParameters: DefaultApiQueryGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.queryGet(requestParameters.q, requestParameters.format, requestParameters.headers, requestParameters.metadata, requestParameters.arrays, requestParameters.tableName, requestParameters.sortColumn, requestParameters.sortDirection, requestParameters.page, requestParameters.perPage, requestParameters.accept, requestParameters.userAgent, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary POST Query
         * @param {DefaultApiQueryPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queryPost(requestParameters: DefaultApiQueryPostRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.queryPost(requestParameters.page, requestParameters.perPage, requestParameters.accept, requestParameters.queryPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create Record
         * @param {DefaultApiRecordsCreateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recordsCreate(requestParameters: DefaultApiRecordsCreateRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.recordsCreate(requestParameters.accept, requestParameters.contentType, requestParameters.xSkipWorkflows, requestParameters.xSkipWebhooks, requestParameters.recordsCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete Record
         * @param {DefaultApiRecordsDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recordsDelete(requestParameters: DefaultApiRecordsDeleteRequest, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.recordsDelete(requestParameters.recordId, requestParameters.accept, requestParameters.xSkipWorkflows, requestParameters.xSkipWebhooks, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get All Records
         * @param {DefaultApiRecordsGetAllRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recordsGetAll(requestParameters: DefaultApiRecordsGetAllRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<RecordsResponse> {
            return localVarFp.recordsGetAll(requestParameters.newestFirst, requestParameters.boundingBox, requestParameters.changesetId, requestParameters.formId, requestParameters.projectId, requestParameters.clientCreatedBefore, requestParameters.clientCreatedSince, requestParameters.clientUpdatedBefore, requestParameters.clientUpdatedSince, requestParameters.createdBefore, requestParameters.createdSince, requestParameters.updatedBefore, requestParameters.updatedSince, requestParameters.page, requestParameters.perPage, requestParameters.accept, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint can help you get records from a specific changeset, or retrieve records for a deleted form.
         * @summary Get All Records History
         * @param {DefaultApiRecordsGetAllHistoryRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recordsGetAllHistory(requestParameters: DefaultApiRecordsGetAllHistoryRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.recordsGetAllHistory(requestParameters.accept, requestParameters.changesetId, requestParameters.deletedFormId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Record History
         * @param {DefaultApiRecordsGetHistoryRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recordsGetHistory(requestParameters: DefaultApiRecordsGetHistoryRequest, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.recordsGetHistory(requestParameters.recordId, requestParameters.accept, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Single Record
         * @param {DefaultApiRecordsGetSingleRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recordsGetSingle(requestParameters: DefaultApiRecordsGetSingleRequest, options?: RawAxiosRequestConfig): AxiosPromise<ModelRecord> {
            return localVarFp.recordsGetSingle(requestParameters.recordId, requestParameters.accept, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update Record
         * @param {DefaultApiRecordsUpdateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recordsUpdate(requestParameters: DefaultApiRecordsUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.recordsUpdate(requestParameters.recordId, requestParameters.accept, requestParameters.contentType, requestParameters.xSkipWorkflows, requestParameters.xSkipWebhooks, requestParameters.recordsUpdateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get All Roles
         * @param {DefaultApiRolesGetAllRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolesGetAll(requestParameters: DefaultApiRolesGetAllRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.rolesGetAll(requestParameters.page, requestParameters.perPage, requestParameters.accept, requestParameters.sort, requestParameters.sortDirection, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get All Signatures
         * @param {DefaultApiSignaturesGetAllRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signaturesGetAll(requestParameters: DefaultApiSignaturesGetAllRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.signaturesGetAll(requestParameters.recordId, requestParameters.formId, requestParameters.newestFirst, requestParameters.processed, requestParameters.stored, requestParameters.uploaded, requestParameters.page, requestParameters.perPage, requestParameters.accept, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Single Signature File
         * @param {DefaultApiSignaturesGetSingleFileRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signaturesGetSingleFile(requestParameters: DefaultApiSignaturesGetSingleFileRequest, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.signaturesGetSingleFile(requestParameters.signatureId, requestParameters.accept, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Single Signature Metadata
         * @param {DefaultApiSignaturesGetSingleMetadataRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signaturesGetSingleMetadata(requestParameters: DefaultApiSignaturesGetSingleMetadataRequest, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.signaturesGetSingleMetadata(requestParameters.signatureId, requestParameters.accept, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Signature Thumbnail File
         * @param {DefaultApiSignaturesGetThumbnailFileRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signaturesGetThumbnailFile(requestParameters: DefaultApiSignaturesGetThumbnailFileRequest, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.signaturesGetThumbnailFile(requestParameters.signatureId, requestParameters.accept, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Signature Thumbnail Metadata
         * @param {DefaultApiSignaturesGetThumbnailMetadataRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signaturesGetThumbnailMetadata(requestParameters: DefaultApiSignaturesGetThumbnailMetadataRequest, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.signaturesGetThumbnailMetadata(requestParameters.signatureId, requestParameters.accept, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Upload Signature
         * @param {DefaultApiSignaturesUploadRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signaturesUpload(requestParameters: DefaultApiSignaturesUploadRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.signaturesUpload(requestParameters.accept, requestParameters.contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * Start your pending batch
         * @summary Start Batch
         * @param {DefaultApiStartBatchRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startBatch(requestParameters: DefaultApiStartBatchRequest, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.startBatch(requestParameters.batchId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update Group Name / Description
         * @param {DefaultApiUpdateGroupNameDescriptionRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGroupNameDescription(requestParameters: DefaultApiUpdateGroupNameDescriptionRequest, options?: RawAxiosRequestConfig): AxiosPromise<CreateGroup201Response> {
            return localVarFp.updateGroupNameDescription(requestParameters.groupId, requestParameters.accept, requestParameters.contentType, requestParameters.updateGroupNameDescriptionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update Group Permissions
         * @param {DefaultApiUpdateGroupPermissionsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGroupPermissions(requestParameters: DefaultApiUpdateGroupPermissionsRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<CreateGroup201Response> {
            return localVarFp.updateGroupPermissions(requestParameters.accept, requestParameters.contentType, requestParameters.updateGroupPermissionsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * You can use this to update parameters of a member, but this will not work if the member is apart of multiple organizations.
         * @summary Update Member
         * @param {DefaultApiUpdateMemberRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMember(requestParameters: DefaultApiUpdateMemberRequest, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.updateMember(requestParameters.membershipId, requestParameters.updateMemberRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update Report Template
         * @param {DefaultApiUpdateReportTemplateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateReportTemplate(requestParameters: DefaultApiUpdateReportTemplateRequest, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.updateReportTemplate(requestParameters.id, requestParameters.updateReportTemplateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update Workflow
         * @param {DefaultApiUpdateWorkflowRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWorkflow(requestParameters: DefaultApiUpdateWorkflowRequest, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.updateWorkflow(requestParameters.workflowId, requestParameters.accept, requestParameters.contentTyoe, requestParameters.updateWorkflowRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get User Information
         * @param {DefaultApiUsersGetUserRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersGetUser(requestParameters: DefaultApiUsersGetUserRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.usersGetUser(requestParameters.page, requestParameters.perPage, requestParameters.accept, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get All Videos
         * @param {DefaultApiVideosGetAllRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        videosGetAll(requestParameters: DefaultApiVideosGetAllRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.videosGetAll(requestParameters.recordId, requestParameters.formId, requestParameters.newestFirst, requestParameters.processed, requestParameters.stored, requestParameters.uploaded, requestParameters.page, requestParameters.perPage, requestParameters.accept, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get GeoJSON Tracks for All Videos
         * @param {DefaultApiVideosGetAllTracksGeojsonRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        videosGetAllTracksGeojson(requestParameters: DefaultApiVideosGetAllTracksGeojsonRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.videosGetAllTracksGeojson(requestParameters.accept, requestParameters.type, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get GPX Tracks for All Videos
         * @param {DefaultApiVideosGetAllTracksGpxRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        videosGetAllTracksGpx(requestParameters: DefaultApiVideosGetAllTracksGpxRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.videosGetAllTracksGpx(requestParameters.accept, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get KML Tracks for All Videos
         * @param {DefaultApiVideosGetAllTracksKmlRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        videosGetAllTracksKml(requestParameters: DefaultApiVideosGetAllTracksKmlRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.videosGetAllTracksKml(requestParameters.accept, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Medium Video File
         * @param {DefaultApiVideosGetMediumFileRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        videosGetMediumFile(requestParameters: DefaultApiVideosGetMediumFileRequest, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.videosGetMediumFile(requestParameters.videoId, requestParameters.accept, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Original Video File
         * @param {DefaultApiVideosGetOriginalFileRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        videosGetOriginalFile(requestParameters: DefaultApiVideosGetOriginalFileRequest, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.videosGetOriginalFile(requestParameters.videoId, requestParameters.accept, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Video Metadata
         * @param {DefaultApiVideosGetSingleMetadataRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        videosGetSingleMetadata(requestParameters: DefaultApiVideosGetSingleMetadataRequest, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.videosGetSingleMetadata(requestParameters.videoId, requestParameters.accept, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get GeoJSON Video Track
         * @param {DefaultApiVideosGetSingleTrackGeojsonRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        videosGetSingleTrackGeojson(requestParameters: DefaultApiVideosGetSingleTrackGeojsonRequest, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.videosGetSingleTrackGeojson(requestParameters.videoId, requestParameters.accept, requestParameters.type, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get GPX Video Track
         * @param {DefaultApiVideosGetSingleTrackGpxRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        videosGetSingleTrackGpx(requestParameters: DefaultApiVideosGetSingleTrackGpxRequest, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.videosGetSingleTrackGpx(requestParameters.videoId, requestParameters.accept, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get JSON Video Track
         * @param {DefaultApiVideosGetSingleTrackJsonRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        videosGetSingleTrackJson(requestParameters: DefaultApiVideosGetSingleTrackJsonRequest, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.videosGetSingleTrackJson(requestParameters.videoId, requestParameters.accept, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get KML Video Track
         * @param {DefaultApiVideosGetSingleTrackKmlRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        videosGetSingleTrackKml(requestParameters: DefaultApiVideosGetSingleTrackKmlRequest, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.videosGetSingleTrackKml(requestParameters.videoId, requestParameters.accept, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Small Video File
         * @param {DefaultApiVideosGetSmallFileRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        videosGetSmallFile(requestParameters: DefaultApiVideosGetSmallFileRequest, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.videosGetSmallFile(requestParameters.videoId, requestParameters.accept, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Huge Video Thumbnail
         * @param {DefaultApiVideosGetThumbnailHugeRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        videosGetThumbnailHuge(requestParameters: DefaultApiVideosGetThumbnailHugeRequest, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.videosGetThumbnailHuge(requestParameters.videoId, requestParameters.accept, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Huge Square Video Thumbnail
         * @param {DefaultApiVideosGetThumbnailHugeSquareRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        videosGetThumbnailHugeSquare(requestParameters: DefaultApiVideosGetThumbnailHugeSquareRequest, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.videosGetThumbnailHugeSquare(requestParameters.videoId, requestParameters.accept, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Large Video Thumbnail
         * @param {DefaultApiVideosGetThumbnailLargeRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        videosGetThumbnailLarge(requestParameters: DefaultApiVideosGetThumbnailLargeRequest, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.videosGetThumbnailLarge(requestParameters.videoId, requestParameters.accept, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Large Square Video Thumbnail
         * @param {DefaultApiVideosGetThumbnailLargeSquareRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        videosGetThumbnailLargeSquare(requestParameters: DefaultApiVideosGetThumbnailLargeSquareRequest, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.videosGetThumbnailLargeSquare(requestParameters.videoId, requestParameters.accept, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Medium Video Thumbnail
         * @param {DefaultApiVideosGetThumbnailMediumRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        videosGetThumbnailMedium(requestParameters: DefaultApiVideosGetThumbnailMediumRequest, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.videosGetThumbnailMedium(requestParameters.videoId, requestParameters.accept, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Medium Square Video Thumbnail
         * @param {DefaultApiVideosGetThumbnailMediumSquareRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        videosGetThumbnailMediumSquare(requestParameters: DefaultApiVideosGetThumbnailMediumSquareRequest, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.videosGetThumbnailMediumSquare(requestParameters.videoId, requestParameters.accept, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Small Video Thumbnail
         * @param {DefaultApiVideosGetThumbnailSmallRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        videosGetThumbnailSmall(requestParameters: DefaultApiVideosGetThumbnailSmallRequest, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.videosGetThumbnailSmall(requestParameters.videoId, requestParameters.accept, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Small Square Video Thumbnail
         * @param {DefaultApiVideosGetThumbnailSmallSquareRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        videosGetThumbnailSmallSquare(requestParameters: DefaultApiVideosGetThumbnailSmallSquareRequest, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.videosGetThumbnailSmallSquare(requestParameters.videoId, requestParameters.accept, options).then((request) => request(axios, basePath));
        },
        /**
         * Upload video with optional track file
         * @summary Upload Video
         * @param {DefaultApiVideosUploadRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        videosUpload(requestParameters: DefaultApiVideosUploadRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.videosUpload(requestParameters.accept, requestParameters.contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create Webhook
         * @param {DefaultApiWebhooksCreateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhooksCreate(requestParameters: DefaultApiWebhooksCreateRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<WebhooksCreate201Response> {
            return localVarFp.webhooksCreate(requestParameters.accept, requestParameters.contentType, requestParameters.webhooksCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete Webhook
         * @param {DefaultApiWebhooksDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhooksDelete(requestParameters: DefaultApiWebhooksDeleteRequest, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.webhooksDelete(requestParameters.webhookId, requestParameters.accept, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get All Webhooks
         * @param {DefaultApiWebhooksGetAllRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhooksGetAll(requestParameters: DefaultApiWebhooksGetAllRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<WebhooksGetAll200Response> {
            return localVarFp.webhooksGetAll(requestParameters.page, requestParameters.perPage, requestParameters.accept, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Single Webhook
         * @param {DefaultApiWebhooksGetSingleRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhooksGetSingle(requestParameters: DefaultApiWebhooksGetSingleRequest, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.webhooksGetSingle(requestParameters.webhookId, requestParameters.accept, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update Webhook
         * @param {DefaultApiWebhooksUpdateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhooksUpdate(requestParameters: DefaultApiWebhooksUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.webhooksUpdate(requestParameters.webhookId, requestParameters.accept, requestParameters.contentType, requestParameters.webhooksUpdateRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DefaultApi - interface
 */
export interface DefaultApiInterface {
    /**
     * Using the batch operations API, you can bulk delete records from a form or update project, assignee, or status values on multiple records.
     * @summary Add batch operations
     * @param {DefaultApiAddBatchOperationsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addBatchOperations(requestParameters: DefaultApiAddBatchOperationsRequest, options?: RawAxiosRequestConfig): AxiosPromise<object>;

    /**
     * 
     * @summary Get All Audio
     * @param {DefaultApiAudioGetAllRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    audioGetAll(requestParameters?: DefaultApiAudioGetAllRequest, options?: RawAxiosRequestConfig): AxiosPromise<object>;

    /**
     * 
     * @summary Get GeoJSON Tracks for All Audio
     * @param {DefaultApiAudioGetAllTracksGeojsonRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    audioGetAllTracksGeojson(requestParameters?: DefaultApiAudioGetAllTracksGeojsonRequest, options?: RawAxiosRequestConfig): AxiosPromise<object>;

    /**
     * 
     * @summary Get GPX Tracks for All Audio
     * @param {DefaultApiAudioGetAllTracksGpxRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    audioGetAllTracksGpx(requestParameters?: DefaultApiAudioGetAllTracksGpxRequest, options?: RawAxiosRequestConfig): AxiosPromise<object>;

    /**
     * 
     * @summary Get JSON Tracks for All Audio
     * @param {DefaultApiAudioGetAllTracksJsonRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    audioGetAllTracksJson(requestParameters?: DefaultApiAudioGetAllTracksJsonRequest, options?: RawAxiosRequestConfig): AxiosPromise<object>;

    /**
     * 
     * @summary Get KML Tracks for All Audio
     * @param {DefaultApiAudioGetAllTracksKmlRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    audioGetAllTracksKml(requestParameters?: DefaultApiAudioGetAllTracksKmlRequest, options?: RawAxiosRequestConfig): AxiosPromise<object>;

    /**
     * 
     * @summary Get Original Audio File
     * @param {DefaultApiAudioGetOriginalFileRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    audioGetOriginalFile(requestParameters: DefaultApiAudioGetOriginalFileRequest, options?: RawAxiosRequestConfig): AxiosPromise<object>;

    /**
     * 
     * @summary Get Audio Metadata
     * @param {DefaultApiAudioGetSingleMetadataRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    audioGetSingleMetadata(requestParameters: DefaultApiAudioGetSingleMetadataRequest, options?: RawAxiosRequestConfig): AxiosPromise<object>;

    /**
     * 
     * @summary Get GeoJSON Audio Track
     * @param {DefaultApiAudioGetSingleTrackGeojsonRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    audioGetSingleTrackGeojson(requestParameters: DefaultApiAudioGetSingleTrackGeojsonRequest, options?: RawAxiosRequestConfig): AxiosPromise<object>;

    /**
     * 
     * @summary Get GPX Audio Track
     * @param {DefaultApiAudioGetSingleTrackGpxRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    audioGetSingleTrackGpx(requestParameters: DefaultApiAudioGetSingleTrackGpxRequest, options?: RawAxiosRequestConfig): AxiosPromise<object>;

    /**
     * 
     * @summary Get JSON Audio Track
     * @param {DefaultApiAudioGetSingleTrackJsonRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    audioGetSingleTrackJson(requestParameters: DefaultApiAudioGetSingleTrackJsonRequest, options?: RawAxiosRequestConfig): AxiosPromise<object>;

    /**
     * 
     * @summary Get KML Audio Track
     * @param {DefaultApiAudioGetSingleTrackKmlRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    audioGetSingleTrackKml(requestParameters: DefaultApiAudioGetSingleTrackKmlRequest, options?: RawAxiosRequestConfig): AxiosPromise<object>;

    /**
     * Upload audio with optional track file
     * @summary Upload Audio
     * @param {DefaultApiAudioUploadRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    audioUpload(requestParameters?: DefaultApiAudioUploadRequest, options?: RawAxiosRequestConfig): AxiosPromise<object>;

    /**
     * 
     * @summary Get All Audit Logs
     * @param {DefaultApiAuditLogsGetAllRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    auditLogsGetAll(requestParameters?: DefaultApiAuditLogsGetAllRequest, options?: RawAxiosRequestConfig): AxiosPromise<object>;

    /**
     * 
     * @summary Get Single Audit Log
     * @param {DefaultApiAuditLogsGetSingleRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    auditLogsGetSingle(requestParameters: DefaultApiAuditLogsGetSingleRequest, options?: RawAxiosRequestConfig): AxiosPromise<object>;

    /**
     * 
     * @summary Create Authorization
     * @param {DefaultApiAuthorizationsCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authorizationsCreate(requestParameters?: DefaultApiAuthorizationsCreateRequest, options?: RawAxiosRequestConfig): AxiosPromise<object>;

    /**
     * 
     * @summary Delete Authorization
     * @param {DefaultApiAuthorizationsDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authorizationsDelete(requestParameters: DefaultApiAuthorizationsDeleteRequest, options?: RawAxiosRequestConfig): AxiosPromise<object>;

    /**
     * 
     * @summary Get All Authorizations
     * @param {DefaultApiAuthorizationsGetAllRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authorizationsGetAll(requestParameters?: DefaultApiAuthorizationsGetAllRequest, options?: RawAxiosRequestConfig): AxiosPromise<object>;

    /**
     * 
     * @summary Get Single Authorization
     * @param {DefaultApiAuthorizationsGetSingleRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authorizationsGetSingle(requestParameters: DefaultApiAuthorizationsGetSingleRequest, options?: RawAxiosRequestConfig): AxiosPromise<object>;

    /**
     * 
     * @summary Update Authorization
     * @param {DefaultApiAuthorizationsUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authorizationsUpdate(requestParameters: DefaultApiAuthorizationsUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<object>;

    /**
     * 
     * @summary Close Changeset
     * @param {DefaultApiChangesetsCloseRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    changesetsClose(requestParameters: DefaultApiChangesetsCloseRequest, options?: RawAxiosRequestConfig): AxiosPromise<object>;

    /**
     * 
     * @summary Create Changeset
     * @param {DefaultApiChangesetsCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    changesetsCreate(requestParameters?: DefaultApiChangesetsCreateRequest, options?: RawAxiosRequestConfig): AxiosPromise<object>;

    /**
     * 
     * @summary Get All Changesets
     * @param {DefaultApiChangesetsGetAllRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    changesetsGetAll(requestParameters?: DefaultApiChangesetsGetAllRequest, options?: RawAxiosRequestConfig): AxiosPromise<object>;

    /**
     * 
     * @summary Get Single Changeset
     * @param {DefaultApiChangesetsGetSingleRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    changesetsGetSingle(requestParameters: DefaultApiChangesetsGetSingleRequest, options?: RawAxiosRequestConfig): AxiosPromise<object>;

    /**
     * 
     * @summary Update Changeset
     * @param {DefaultApiChangesetsUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    changesetsUpdate(requestParameters: DefaultApiChangesetsUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<object>;

    /**
     * 
     * @summary Create Choice List
     * @param {DefaultApiChoiceListsCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    choiceListsCreate(requestParameters?: DefaultApiChoiceListsCreateRequest, options?: RawAxiosRequestConfig): AxiosPromise<object>;

    /**
     * 
     * @summary Delete Choice List
     * @param {DefaultApiChoiceListsDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    choiceListsDelete(requestParameters: DefaultApiChoiceListsDeleteRequest, options?: RawAxiosRequestConfig): AxiosPromise<object>;

    /**
     * 
     * @summary Get All Choice Lists
     * @param {DefaultApiChoiceListsGetAllRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    choiceListsGetAll(requestParameters?: DefaultApiChoiceListsGetAllRequest, options?: RawAxiosRequestConfig): AxiosPromise<object>;

    /**
     * 
     * @summary Get Single Choice List
     * @param {DefaultApiChoiceListsGetSingleRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    choiceListsGetSingle(requestParameters: DefaultApiChoiceListsGetSingleRequest, options?: RawAxiosRequestConfig): AxiosPromise<object>;

    /**
     * 
     * @summary Update Choice List
     * @param {DefaultApiChoiceListsUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    choiceListsUpdate(requestParameters: DefaultApiChoiceListsUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<object>;

    /**
     * 
     * @summary Create Classification Set
     * @param {DefaultApiClassificationSetsCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    classificationSetsCreate(requestParameters?: DefaultApiClassificationSetsCreateRequest, options?: RawAxiosRequestConfig): AxiosPromise<object>;

    /**
     * 
     * @summary Delete Classification Set
     * @param {DefaultApiClassificationSetsDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    classificationSetsDelete(requestParameters: DefaultApiClassificationSetsDeleteRequest, options?: RawAxiosRequestConfig): AxiosPromise<object>;

    /**
     * 
     * @summary Get All Classification Sets
     * @param {DefaultApiClassificationSetsGetAllRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    classificationSetsGetAll(requestParameters?: DefaultApiClassificationSetsGetAllRequest, options?: RawAxiosRequestConfig): AxiosPromise<object>;

    /**
     * 
     * @summary Get Single Classification Set
     * @param {DefaultApiClassificationSetsGetSingleRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    classificationSetsGetSingle(requestParameters: DefaultApiClassificationSetsGetSingleRequest, options?: RawAxiosRequestConfig): AxiosPromise<object>;

    /**
     * 
     * @summary Update Classification Set
     * @param {DefaultApiClassificationSetsUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    classificationSetsUpdate(requestParameters: DefaultApiClassificationSetsUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<object>;

    /**
     * There is only one parameter that is required for creating an attachment: `owners`. You must specify at least one owner of type `record` or `form`. If you create a `record` attachment you can optionally include a `name` and `file_size`. The name will be the name of the file shown in the record information. The file_size is only used for verifying that uploading this attachment will not exceed your current storage limit. If no file_size is provided the attachment may be rejected once it has been uploaded. The response will provide the `url` to upload (PUT) the file to.
     * @summary Create Attachment
     * @param {DefaultApiCreateAttachmentRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createAttachment(requestParameters?: DefaultApiCreateAttachmentRequest, options?: RawAxiosRequestConfig): AxiosPromise<CreateAttachment200Response>;

    /**
     * Using the batch operations API, you can bulk delete records from a form.
     * @summary Create Batch to Bulk Delete Records
     * @param {DefaultApiCreateBatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createBatch(requestParameters?: DefaultApiCreateBatchRequest, options?: RawAxiosRequestConfig): AxiosPromise<object>;

    /**
     * 
     * @summary Create Group
     * @param {DefaultApiCreateGroupRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createGroup(requestParameters?: DefaultApiCreateGroupRequest, options?: RawAxiosRequestConfig): AxiosPromise<CreateGroup201Response>;

    /**
     * 
     * @summary Create Member
     * @param {DefaultApiCreateMemberRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createMember(requestParameters?: DefaultApiCreateMemberRequest, options?: RawAxiosRequestConfig): AxiosPromise<object>;

    /**
     * 
     * @summary Create Report Template
     * @param {DefaultApiCreateReportTemplateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createReportTemplate(requestParameters?: DefaultApiCreateReportTemplateRequest, options?: RawAxiosRequestConfig): AxiosPromise<object>;

    /**
     * 
     * @summary Create Workflow
     * @param {DefaultApiCreateWorkflowRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createWorkflow(requestParameters?: DefaultApiCreateWorkflowRequest, options?: RawAxiosRequestConfig): AxiosPromise<object>;

    /**
     * The delete endpoint only applies to Form attachments. Use this endpoint to delete an attachment. For record attachments, simply remove the association of an attachment from the record and the attachment will be deleted.
     * @summary Delete Attachment
     * @param {DefaultApiDeleteAttachmentRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteAttachment(requestParameters: DefaultApiDeleteAttachmentRequest, options?: RawAxiosRequestConfig): AxiosPromise<object>;

    /**
     * 
     * @summary Delete Group
     * @param {DefaultApiDeleteGroupRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteGroup(requestParameters: DefaultApiDeleteGroupRequest, options?: RawAxiosRequestConfig): AxiosPromise<object>;

    /**
     * 
     * @summary Delete Member
     * @param {DefaultApiDeleteMemberRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteMember(requestParameters: DefaultApiDeleteMemberRequest, options?: RawAxiosRequestConfig): AxiosPromise<object>;

    /**
     * 
     * @summary Delete Report Template
     * @param {DefaultApiDeleteReportTemplateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteReportTemplate(requestParameters: DefaultApiDeleteReportTemplateRequest, options?: RawAxiosRequestConfig): AxiosPromise<object>;

    /**
     * 
     * @summary Delete Workflow
     * @param {DefaultApiDeleteWorkflowRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteWorkflow(requestParameters: DefaultApiDeleteWorkflowRequest, options?: RawAxiosRequestConfig): AxiosPromise<object>;

    /**
     * The finalize endpoint is a required step for Form attachments. Use this endpoint to tell Fulcrum that your attachment has been uploaded.
     * @summary Finalize Attachment
     * @param {DefaultApiFinalizeAttachmentRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    finalizeAttachment(requestParameters?: DefaultApiFinalizeAttachmentRequest, options?: RawAxiosRequestConfig): AxiosPromise<object>;

    /**
     * 
     * @summary Create Form
     * @param {DefaultApiFormsCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    formsCreate(requestParameters?: DefaultApiFormsCreateRequest, options?: RawAxiosRequestConfig): AxiosPromise<object>;

    /**
     * 
     * @summary Delete Form
     * @param {DefaultApiFormsDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    formsDelete(requestParameters: DefaultApiFormsDeleteRequest, options?: RawAxiosRequestConfig): AxiosPromise<object>;

    /**
     * 
     * @summary Get All Forms
     * @param {DefaultApiFormsGetAllRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    formsGetAll(requestParameters?: DefaultApiFormsGetAllRequest, options?: RawAxiosRequestConfig): AxiosPromise<object>;

    /**
     * 
     * @summary Get Form History
     * @param {DefaultApiFormsGetHistoryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    formsGetHistory(requestParameters: DefaultApiFormsGetHistoryRequest, options?: RawAxiosRequestConfig): AxiosPromise<object>;

    /**
     * 
     * @summary Get Single Form
     * @param {DefaultApiFormsGetSingleRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    formsGetSingle(requestParameters: DefaultApiFormsGetSingleRequest, options?: RawAxiosRequestConfig): AxiosPromise<object>;

    /**
     * 
     * @summary Update Form
     * @param {DefaultApiFormsUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    formsUpdate(requestParameters: DefaultApiFormsUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<object>;

    /**
     * 
     * @summary Get All Attachments
     * @param {DefaultApiGetAllAttachmentsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllAttachments(requestParameters?: DefaultApiGetAllAttachmentsRequest, options?: RawAxiosRequestConfig): AxiosPromise<GetAllAttachments200Response>;

    /**
     * 
     * @summary Get All Batches
     * @param {DefaultApiGetAllBatchesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllBatches(requestParameters?: DefaultApiGetAllBatchesRequest, options?: RawAxiosRequestConfig): AxiosPromise<object>;

    /**
     * 
     * @summary Get All Groups
     * @param {DefaultApiGetAllGroupsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllGroups(requestParameters?: DefaultApiGetAllGroupsRequest, options?: RawAxiosRequestConfig): AxiosPromise<object>;

    /**
     * 
     * @summary Get Membership Permissions
     * @param {DefaultApiGetAllMembershipsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllMemberships(requestParameters: DefaultApiGetAllMembershipsRequest, options?: RawAxiosRequestConfig): AxiosPromise<object>;

    /**
     * 
     * @summary Get All Report Templates
     * @param {DefaultApiGetAllReportTemplatesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllReportTemplates(requestParameters?: DefaultApiGetAllReportTemplatesRequest, options?: RawAxiosRequestConfig): AxiosPromise<object>;

    /**
     * 
     * @summary Get All Workflows
     * @param {DefaultApiGetAllWorkflowsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllWorkflows(requestParameters?: DefaultApiGetAllWorkflowsRequest, options?: RawAxiosRequestConfig): AxiosPromise<object>;

    /**
     * 
     * @summary Get Group Resource
     * @param {DefaultApiGetGroupResourceRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getGroupResource(requestParameters: DefaultApiGetGroupResourceRequest, options?: RawAxiosRequestConfig): AxiosPromise<object>;

    /**
     * 
     * @summary Get Single Attachment
     * @param {DefaultApiGetSingleAttachmentRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSingleAttachment(requestParameters: DefaultApiGetSingleAttachmentRequest, options?: RawAxiosRequestConfig): AxiosPromise<GetSingleAttachment200Response>;

    /**
     * 
     * @summary Get Single Batch
     * @param {DefaultApiGetSingleBatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSingleBatch(requestParameters: DefaultApiGetSingleBatchRequest, options?: RawAxiosRequestConfig): AxiosPromise<object>;

    /**
     * 
     * @summary Get Single Group
     * @param {DefaultApiGetSingleGroupRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSingleGroup(requestParameters: DefaultApiGetSingleGroupRequest, options?: RawAxiosRequestConfig): AxiosPromise<object>;

    /**
     * 
     * @summary Get Single Report Template
     * @param {DefaultApiGetSingleReportTemplateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSingleReportTemplate(requestParameters: DefaultApiGetSingleReportTemplateRequest, options?: RawAxiosRequestConfig): AxiosPromise<object>;

    /**
     * 
     * @summary Get Single Workflow
     * @param {DefaultApiGetSingleWorkflowRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSingleWorkflow(requestParameters: DefaultApiGetSingleWorkflowRequest, options?: RawAxiosRequestConfig): AxiosPromise<object>;

    /**
     * 
     * @summary Create Layer
     * @param {DefaultApiLayersCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    layersCreate(requestParameters?: DefaultApiLayersCreateRequest, options?: RawAxiosRequestConfig): AxiosPromise<object>;

    /**
     * 
     * @summary Delete Layer
     * @param {DefaultApiLayersDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    layersDelete(requestParameters: DefaultApiLayersDeleteRequest, options?: RawAxiosRequestConfig): AxiosPromise<object>;

    /**
     * 
     * @summary Get All Layers
     * @param {DefaultApiLayersGetAllRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    layersGetAll(requestParameters?: DefaultApiLayersGetAllRequest, options?: RawAxiosRequestConfig): AxiosPromise<object>;

    /**
     * 
     * @summary Get Single Layer
     * @param {DefaultApiLayersGetSingleRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    layersGetSingle(requestParameters: DefaultApiLayersGetSingleRequest, options?: RawAxiosRequestConfig): AxiosPromise<object>;

    /**
     * 
     * @summary Update Layer
     * @param {DefaultApiLayersUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    layersUpdate(requestParameters: DefaultApiLayersUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<object>;

    /**
     * Add or remove membership permissions from layers, forms, or projects
     * @summary Change Permissions
     * @param {DefaultApiMembershipsChangePermissionsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    membershipsChangePermissions(requestParameters?: DefaultApiMembershipsChangePermissionsRequest, options?: RawAxiosRequestConfig): AxiosPromise<object>;

    /**
     * 
     * @summary Get All Memberships
     * @param {DefaultApiMembershipsGetAllRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    membershipsGetAll(requestParameters?: DefaultApiMembershipsGetAllRequest, options?: RawAxiosRequestConfig): AxiosPromise<object>;

    /**
     * 
     * @summary Get Single Membership
     * @param {DefaultApiMembershipsGetSingleRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    membershipsGetSingle(requestParameters: DefaultApiMembershipsGetSingleRequest, options?: RawAxiosRequestConfig): AxiosPromise<object>;

    /**
     * 
     * @summary Get All Photos
     * @param {DefaultApiPhotosGetAllMetadataRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    photosGetAllMetadata(requestParameters?: DefaultApiPhotosGetAllMetadataRequest, options?: RawAxiosRequestConfig): AxiosPromise<object>;

    /**
     * 
     * @summary Get Single Photo File
     * @param {DefaultApiPhotosGetSingleFileRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    photosGetSingleFile(requestParameters: DefaultApiPhotosGetSingleFileRequest, options?: RawAxiosRequestConfig): AxiosPromise<object>;

    /**
     * 
     * @summary Get Single Photo Metadata
     * @param {DefaultApiPhotosGetSingleMetadataRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    photosGetSingleMetadata(requestParameters: DefaultApiPhotosGetSingleMetadataRequest, options?: RawAxiosRequestConfig): AxiosPromise<object>;

    /**
     * 
     * @summary Photo Large File
     * @param {DefaultApiPhotosLargeFileRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    photosLargeFile(requestParameters: DefaultApiPhotosLargeFileRequest, options?: RawAxiosRequestConfig): AxiosPromise<object>;

    /**
     * 
     * @summary Photo Large Metadata
     * @param {DefaultApiPhotosLargeMetadataRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    photosLargeMetadata(requestParameters: DefaultApiPhotosLargeMetadataRequest, options?: RawAxiosRequestConfig): AxiosPromise<object>;

    /**
     * 
     * @summary Photo Thumbnail File
     * @param {DefaultApiPhotosThumbnailFileRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    photosThumbnailFile(requestParameters: DefaultApiPhotosThumbnailFileRequest, options?: RawAxiosRequestConfig): AxiosPromise<object>;

    /**
     * 
     * @summary Photo Thumbnail Metadata
     * @param {DefaultApiPhotosThumbnailMetadataRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    photosThumbnailMetadata(requestParameters: DefaultApiPhotosThumbnailMetadataRequest, options?: RawAxiosRequestConfig): AxiosPromise<object>;

    /**
     * 
     * @summary Upload Photo
     * @param {DefaultApiPhotosUploadRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    photosUpload(requestParameters?: DefaultApiPhotosUploadRequest, options?: RawAxiosRequestConfig): AxiosPromise<object>;

    /**
     * 
     * @summary Create Project
     * @param {DefaultApiProjectsCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    projectsCreate(requestParameters?: DefaultApiProjectsCreateRequest, options?: RawAxiosRequestConfig): AxiosPromise<object>;

    /**
     * 
     * @summary Delete Project
     * @param {DefaultApiProjectsDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    projectsDelete(requestParameters: DefaultApiProjectsDeleteRequest, options?: RawAxiosRequestConfig): AxiosPromise<object>;

    /**
     * 
     * @summary Get All Projects
     * @param {DefaultApiProjectsGetAllRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    projectsGetAll(requestParameters?: DefaultApiProjectsGetAllRequest, options?: RawAxiosRequestConfig): AxiosPromise<object>;

    /**
     * 
     * @summary Get Single Project
     * @param {DefaultApiProjectsGetSingleRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    projectsGetSingle(requestParameters: DefaultApiProjectsGetSingleRequest, options?: RawAxiosRequestConfig): AxiosPromise<object>;

    /**
     * 
     * @summary Update Project
     * @param {DefaultApiProjectsUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    projectsUpdate(requestParameters: DefaultApiProjectsUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<object>;

    /**
     * 
     * @summary GET Query
     * @param {DefaultApiQueryGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    queryGet(requestParameters: DefaultApiQueryGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<object>;

    /**
     * 
     * @summary POST Query
     * @param {DefaultApiQueryPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    queryPost(requestParameters?: DefaultApiQueryPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<object>;

    /**
     * 
     * @summary Create Record
     * @param {DefaultApiRecordsCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    recordsCreate(requestParameters?: DefaultApiRecordsCreateRequest, options?: RawAxiosRequestConfig): AxiosPromise<object>;

    /**
     * 
     * @summary Delete Record
     * @param {DefaultApiRecordsDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    recordsDelete(requestParameters: DefaultApiRecordsDeleteRequest, options?: RawAxiosRequestConfig): AxiosPromise<object>;

    /**
     * 
     * @summary Get All Records
     * @param {DefaultApiRecordsGetAllRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    recordsGetAll(requestParameters?: DefaultApiRecordsGetAllRequest, options?: RawAxiosRequestConfig): AxiosPromise<RecordsResponse>;

    /**
     * This endpoint can help you get records from a specific changeset, or retrieve records for a deleted form.
     * @summary Get All Records History
     * @param {DefaultApiRecordsGetAllHistoryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    recordsGetAllHistory(requestParameters?: DefaultApiRecordsGetAllHistoryRequest, options?: RawAxiosRequestConfig): AxiosPromise<object>;

    /**
     * 
     * @summary Get Record History
     * @param {DefaultApiRecordsGetHistoryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    recordsGetHistory(requestParameters: DefaultApiRecordsGetHistoryRequest, options?: RawAxiosRequestConfig): AxiosPromise<object>;

    /**
     * 
     * @summary Get Single Record
     * @param {DefaultApiRecordsGetSingleRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    recordsGetSingle(requestParameters: DefaultApiRecordsGetSingleRequest, options?: RawAxiosRequestConfig): AxiosPromise<ModelRecord>;

    /**
     * 
     * @summary Update Record
     * @param {DefaultApiRecordsUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    recordsUpdate(requestParameters: DefaultApiRecordsUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<object>;

    /**
     * 
     * @summary Get All Roles
     * @param {DefaultApiRolesGetAllRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    rolesGetAll(requestParameters?: DefaultApiRolesGetAllRequest, options?: RawAxiosRequestConfig): AxiosPromise<object>;

    /**
     * 
     * @summary Get All Signatures
     * @param {DefaultApiSignaturesGetAllRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    signaturesGetAll(requestParameters?: DefaultApiSignaturesGetAllRequest, options?: RawAxiosRequestConfig): AxiosPromise<object>;

    /**
     * 
     * @summary Get Single Signature File
     * @param {DefaultApiSignaturesGetSingleFileRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    signaturesGetSingleFile(requestParameters: DefaultApiSignaturesGetSingleFileRequest, options?: RawAxiosRequestConfig): AxiosPromise<object>;

    /**
     * 
     * @summary Get Single Signature Metadata
     * @param {DefaultApiSignaturesGetSingleMetadataRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    signaturesGetSingleMetadata(requestParameters: DefaultApiSignaturesGetSingleMetadataRequest, options?: RawAxiosRequestConfig): AxiosPromise<object>;

    /**
     * 
     * @summary Signature Thumbnail File
     * @param {DefaultApiSignaturesGetThumbnailFileRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    signaturesGetThumbnailFile(requestParameters: DefaultApiSignaturesGetThumbnailFileRequest, options?: RawAxiosRequestConfig): AxiosPromise<object>;

    /**
     * 
     * @summary Signature Thumbnail Metadata
     * @param {DefaultApiSignaturesGetThumbnailMetadataRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    signaturesGetThumbnailMetadata(requestParameters: DefaultApiSignaturesGetThumbnailMetadataRequest, options?: RawAxiosRequestConfig): AxiosPromise<object>;

    /**
     * 
     * @summary Upload Signature
     * @param {DefaultApiSignaturesUploadRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    signaturesUpload(requestParameters?: DefaultApiSignaturesUploadRequest, options?: RawAxiosRequestConfig): AxiosPromise<object>;

    /**
     * Start your pending batch
     * @summary Start Batch
     * @param {DefaultApiStartBatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    startBatch(requestParameters: DefaultApiStartBatchRequest, options?: RawAxiosRequestConfig): AxiosPromise<object>;

    /**
     * 
     * @summary Update Group Name / Description
     * @param {DefaultApiUpdateGroupNameDescriptionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateGroupNameDescription(requestParameters: DefaultApiUpdateGroupNameDescriptionRequest, options?: RawAxiosRequestConfig): AxiosPromise<CreateGroup201Response>;

    /**
     * 
     * @summary Update Group Permissions
     * @param {DefaultApiUpdateGroupPermissionsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateGroupPermissions(requestParameters?: DefaultApiUpdateGroupPermissionsRequest, options?: RawAxiosRequestConfig): AxiosPromise<CreateGroup201Response>;

    /**
     * You can use this to update parameters of a member, but this will not work if the member is apart of multiple organizations.
     * @summary Update Member
     * @param {DefaultApiUpdateMemberRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateMember(requestParameters: DefaultApiUpdateMemberRequest, options?: RawAxiosRequestConfig): AxiosPromise<object>;

    /**
     * 
     * @summary Update Report Template
     * @param {DefaultApiUpdateReportTemplateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateReportTemplate(requestParameters: DefaultApiUpdateReportTemplateRequest, options?: RawAxiosRequestConfig): AxiosPromise<object>;

    /**
     * 
     * @summary Update Workflow
     * @param {DefaultApiUpdateWorkflowRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateWorkflow(requestParameters: DefaultApiUpdateWorkflowRequest, options?: RawAxiosRequestConfig): AxiosPromise<object>;

    /**
     * 
     * @summary Get User Information
     * @param {DefaultApiUsersGetUserRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersGetUser(requestParameters?: DefaultApiUsersGetUserRequest, options?: RawAxiosRequestConfig): AxiosPromise<object>;

    /**
     * 
     * @summary Get All Videos
     * @param {DefaultApiVideosGetAllRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    videosGetAll(requestParameters?: DefaultApiVideosGetAllRequest, options?: RawAxiosRequestConfig): AxiosPromise<object>;

    /**
     * 
     * @summary Get GeoJSON Tracks for All Videos
     * @param {DefaultApiVideosGetAllTracksGeojsonRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    videosGetAllTracksGeojson(requestParameters?: DefaultApiVideosGetAllTracksGeojsonRequest, options?: RawAxiosRequestConfig): AxiosPromise<object>;

    /**
     * 
     * @summary Get GPX Tracks for All Videos
     * @param {DefaultApiVideosGetAllTracksGpxRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    videosGetAllTracksGpx(requestParameters?: DefaultApiVideosGetAllTracksGpxRequest, options?: RawAxiosRequestConfig): AxiosPromise<object>;

    /**
     * 
     * @summary Get KML Tracks for All Videos
     * @param {DefaultApiVideosGetAllTracksKmlRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    videosGetAllTracksKml(requestParameters?: DefaultApiVideosGetAllTracksKmlRequest, options?: RawAxiosRequestConfig): AxiosPromise<object>;

    /**
     * 
     * @summary Get Medium Video File
     * @param {DefaultApiVideosGetMediumFileRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    videosGetMediumFile(requestParameters: DefaultApiVideosGetMediumFileRequest, options?: RawAxiosRequestConfig): AxiosPromise<object>;

    /**
     * 
     * @summary Get Original Video File
     * @param {DefaultApiVideosGetOriginalFileRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    videosGetOriginalFile(requestParameters: DefaultApiVideosGetOriginalFileRequest, options?: RawAxiosRequestConfig): AxiosPromise<object>;

    /**
     * 
     * @summary Get Video Metadata
     * @param {DefaultApiVideosGetSingleMetadataRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    videosGetSingleMetadata(requestParameters: DefaultApiVideosGetSingleMetadataRequest, options?: RawAxiosRequestConfig): AxiosPromise<object>;

    /**
     * 
     * @summary Get GeoJSON Video Track
     * @param {DefaultApiVideosGetSingleTrackGeojsonRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    videosGetSingleTrackGeojson(requestParameters: DefaultApiVideosGetSingleTrackGeojsonRequest, options?: RawAxiosRequestConfig): AxiosPromise<object>;

    /**
     * 
     * @summary Get GPX Video Track
     * @param {DefaultApiVideosGetSingleTrackGpxRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    videosGetSingleTrackGpx(requestParameters: DefaultApiVideosGetSingleTrackGpxRequest, options?: RawAxiosRequestConfig): AxiosPromise<object>;

    /**
     * 
     * @summary Get JSON Video Track
     * @param {DefaultApiVideosGetSingleTrackJsonRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    videosGetSingleTrackJson(requestParameters: DefaultApiVideosGetSingleTrackJsonRequest, options?: RawAxiosRequestConfig): AxiosPromise<object>;

    /**
     * 
     * @summary Get KML Video Track
     * @param {DefaultApiVideosGetSingleTrackKmlRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    videosGetSingleTrackKml(requestParameters: DefaultApiVideosGetSingleTrackKmlRequest, options?: RawAxiosRequestConfig): AxiosPromise<object>;

    /**
     * 
     * @summary Get Small Video File
     * @param {DefaultApiVideosGetSmallFileRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    videosGetSmallFile(requestParameters: DefaultApiVideosGetSmallFileRequest, options?: RawAxiosRequestConfig): AxiosPromise<object>;

    /**
     * 
     * @summary Get Huge Video Thumbnail
     * @param {DefaultApiVideosGetThumbnailHugeRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    videosGetThumbnailHuge(requestParameters: DefaultApiVideosGetThumbnailHugeRequest, options?: RawAxiosRequestConfig): AxiosPromise<object>;

    /**
     * 
     * @summary Get Huge Square Video Thumbnail
     * @param {DefaultApiVideosGetThumbnailHugeSquareRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    videosGetThumbnailHugeSquare(requestParameters: DefaultApiVideosGetThumbnailHugeSquareRequest, options?: RawAxiosRequestConfig): AxiosPromise<object>;

    /**
     * 
     * @summary Get Large Video Thumbnail
     * @param {DefaultApiVideosGetThumbnailLargeRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    videosGetThumbnailLarge(requestParameters: DefaultApiVideosGetThumbnailLargeRequest, options?: RawAxiosRequestConfig): AxiosPromise<object>;

    /**
     * 
     * @summary Get Large Square Video Thumbnail
     * @param {DefaultApiVideosGetThumbnailLargeSquareRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    videosGetThumbnailLargeSquare(requestParameters: DefaultApiVideosGetThumbnailLargeSquareRequest, options?: RawAxiosRequestConfig): AxiosPromise<object>;

    /**
     * 
     * @summary Get Medium Video Thumbnail
     * @param {DefaultApiVideosGetThumbnailMediumRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    videosGetThumbnailMedium(requestParameters: DefaultApiVideosGetThumbnailMediumRequest, options?: RawAxiosRequestConfig): AxiosPromise<object>;

    /**
     * 
     * @summary Get Medium Square Video Thumbnail
     * @param {DefaultApiVideosGetThumbnailMediumSquareRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    videosGetThumbnailMediumSquare(requestParameters: DefaultApiVideosGetThumbnailMediumSquareRequest, options?: RawAxiosRequestConfig): AxiosPromise<object>;

    /**
     * 
     * @summary Get Small Video Thumbnail
     * @param {DefaultApiVideosGetThumbnailSmallRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    videosGetThumbnailSmall(requestParameters: DefaultApiVideosGetThumbnailSmallRequest, options?: RawAxiosRequestConfig): AxiosPromise<object>;

    /**
     * 
     * @summary Get Small Square Video Thumbnail
     * @param {DefaultApiVideosGetThumbnailSmallSquareRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    videosGetThumbnailSmallSquare(requestParameters: DefaultApiVideosGetThumbnailSmallSquareRequest, options?: RawAxiosRequestConfig): AxiosPromise<object>;

    /**
     * Upload video with optional track file
     * @summary Upload Video
     * @param {DefaultApiVideosUploadRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    videosUpload(requestParameters?: DefaultApiVideosUploadRequest, options?: RawAxiosRequestConfig): AxiosPromise<object>;

    /**
     * 
     * @summary Create Webhook
     * @param {DefaultApiWebhooksCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    webhooksCreate(requestParameters?: DefaultApiWebhooksCreateRequest, options?: RawAxiosRequestConfig): AxiosPromise<WebhooksCreate201Response>;

    /**
     * 
     * @summary Delete Webhook
     * @param {DefaultApiWebhooksDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    webhooksDelete(requestParameters: DefaultApiWebhooksDeleteRequest, options?: RawAxiosRequestConfig): AxiosPromise<object>;

    /**
     * 
     * @summary Get All Webhooks
     * @param {DefaultApiWebhooksGetAllRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    webhooksGetAll(requestParameters?: DefaultApiWebhooksGetAllRequest, options?: RawAxiosRequestConfig): AxiosPromise<WebhooksGetAll200Response>;

    /**
     * 
     * @summary Get Single Webhook
     * @param {DefaultApiWebhooksGetSingleRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    webhooksGetSingle(requestParameters: DefaultApiWebhooksGetSingleRequest, options?: RawAxiosRequestConfig): AxiosPromise<object>;

    /**
     * 
     * @summary Update Webhook
     * @param {DefaultApiWebhooksUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    webhooksUpdate(requestParameters: DefaultApiWebhooksUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<object>;

}

/**
 * Request parameters for addBatchOperations operation in DefaultApi.
 */
export interface DefaultApiAddBatchOperationsRequest {
    /**
     * ID of the batch
     */
    readonly batchId: string

    readonly addBatchOperationsRequest?: AddBatchOperationsRequest
}

/**
 * Request parameters for audioGetAll operation in DefaultApi.
 */
export interface DefaultApiAudioGetAllRequest {
    /**
     * The ID of the record with which the video is associated.
     */
    readonly recordId?: string

    /**
     * The ID of the form with which the video is associated. Leaving this blank will query against all of your videos.
     */
    readonly formId?: string

    /**
     * If present, videos will be sorted by updated_at date.
     */
    readonly newestFirst?: boolean

    /**
     * Video has been completely processed.
     */
    readonly processed?: boolean

    /**
     * Video has been completely stored.
     */
    readonly stored?: boolean

    /**
     * Video has been completely uploaded.
     */
    readonly uploaded?: boolean

    /**
     * The page number requested
     */
    readonly page?: number

    /**
     * Number of items per page
     */
    readonly perPage?: number

    readonly accept?: string
}

/**
 * Request parameters for audioGetAllTracksGeojson operation in DefaultApi.
 */
export interface DefaultApiAudioGetAllTracksGeojsonRequest {
    readonly accept?: string

    /**
     * Set value to &#x60;points&#x60; to fetch tracks as GeoJSON points
     */
    readonly type?: string
}

/**
 * Request parameters for audioGetAllTracksGpx operation in DefaultApi.
 */
export interface DefaultApiAudioGetAllTracksGpxRequest {
    readonly accept?: string
}

/**
 * Request parameters for audioGetAllTracksJson operation in DefaultApi.
 */
export interface DefaultApiAudioGetAllTracksJsonRequest {
    readonly accept?: string
}

/**
 * Request parameters for audioGetAllTracksKml operation in DefaultApi.
 */
export interface DefaultApiAudioGetAllTracksKmlRequest {
    readonly accept?: string
}

/**
 * Request parameters for audioGetOriginalFile operation in DefaultApi.
 */
export interface DefaultApiAudioGetOriginalFileRequest {
    /**
     * Audio ID
     */
    readonly audioId: string

    readonly accept?: string
}

/**
 * Request parameters for audioGetSingleMetadata operation in DefaultApi.
 */
export interface DefaultApiAudioGetSingleMetadataRequest {
    /**
     * Audio ID
     */
    readonly audioId: string

    readonly accept?: string
}

/**
 * Request parameters for audioGetSingleTrackGeojson operation in DefaultApi.
 */
export interface DefaultApiAudioGetSingleTrackGeojsonRequest {
    /**
     * Audio ID
     */
    readonly audioId: string

    readonly accept?: string

    /**
     * Set value to &#x60;points&#x60; to fetch tracks as GeoJSON points
     */
    readonly type?: string
}

/**
 * Request parameters for audioGetSingleTrackGpx operation in DefaultApi.
 */
export interface DefaultApiAudioGetSingleTrackGpxRequest {
    /**
     * Audio ID
     */
    readonly audioId: string

    readonly accept?: string
}

/**
 * Request parameters for audioGetSingleTrackJson operation in DefaultApi.
 */
export interface DefaultApiAudioGetSingleTrackJsonRequest {
    /**
     * Audio ID
     */
    readonly audioId: string

    readonly accept?: string
}

/**
 * Request parameters for audioGetSingleTrackKml operation in DefaultApi.
 */
export interface DefaultApiAudioGetSingleTrackKmlRequest {
    /**
     * Audio ID
     */
    readonly audioId: string

    readonly accept?: string
}

/**
 * Request parameters for audioUpload operation in DefaultApi.
 */
export interface DefaultApiAudioUploadRequest {
    readonly accept?: string

    readonly contentType?: string
}

/**
 * Request parameters for auditLogsGetAll operation in DefaultApi.
 */
export interface DefaultApiAuditLogsGetAllRequest {
    /**
     * Valid options include: &#x60;export&#x60;, &#x60;data_export&#x60;, &#x60;membership&#x60;, &#x60;layer&#x60;, &#x60;project&#x60;, &#x60;audit_log&#x60;, &#x60;role&#x60;, &#x60;form&#x60;, &#x60;data_share&#x60;, &#x60;classification_set&#x60;, &#x60;authorization&#x60;, &#x60;choice_list&#x60;, &#x60;import&#x60;, &#x60;organization&#x60;, &#x60;workflow&#x60;, &#x60;webhook&#x60;
     */
    readonly source?: string

    /**
     * The available actions vary by log type but a complete list of valid actions includes: &#x60;update&#x60;, &#x60;create&#x60;, &#x60;permission_update&#x60;, &#x60;download&#x60;, &#x60;delete&#x60;, &#x60;reset&#x60;, &#x60;share_enabled&#x60;, &#x60;share_disabled&#x60;, &#x60;update_credit_card&#x60;, &#x60;plan_change&#x60;, &#x60;billing_emails_change&#x60;, &#x60;update_storage&#x60;, &#x60;add_credit&#x60;, &#x60;change_default&#x60;.
     */
    readonly activity?: string

    /**
     * Filter by ip address of the of the audit log action. The ip address must be an exact match in order to return in values from this filter.
     */
    readonly ip?: string

    /**
     * Filter by user responsible for the logged changes. This parameter must be the Fulcrum resource id for the user in question, which can be obtained from the membership API.
     */
    readonly user?: string

    /**
     * Returns log entries since the given unix timestamp.
     */
    readonly updatedSince?: string

    /**
     * Returns log entries before the given unix timestamp.
     */
    readonly updatedBefore?: string

    /**
     * The page number requested
     */
    readonly page?: number

    /**
     * Number of items per page
     */
    readonly perPage?: number

    readonly accept?: string
}

/**
 * Request parameters for auditLogsGetSingle operation in DefaultApi.
 */
export interface DefaultApiAuditLogsGetSingleRequest {
    /**
     * Audit Log ID
     */
    readonly auditLogId: string

    readonly accept?: string
}

/**
 * Request parameters for authorizationsCreate operation in DefaultApi.
 */
export interface DefaultApiAuthorizationsCreateRequest {
    readonly accept?: string

    readonly contentType?: string

    readonly authorizationsCreateRequest?: AuthorizationsCreateRequest
}

/**
 * Request parameters for authorizationsDelete operation in DefaultApi.
 */
export interface DefaultApiAuthorizationsDeleteRequest {
    /**
     * Authorization ID
     */
    readonly authorizationId: string

    readonly accept?: string
}

/**
 * Request parameters for authorizationsGetAll operation in DefaultApi.
 */
export interface DefaultApiAuthorizationsGetAllRequest {
    /**
     * The page number requested
     */
    readonly page?: number

    /**
     * Number of items per page
     */
    readonly perPage?: number

    readonly accept?: string
}

/**
 * Request parameters for authorizationsGetSingle operation in DefaultApi.
 */
export interface DefaultApiAuthorizationsGetSingleRequest {
    /**
     * Authorization ID
     */
    readonly authorizationId: string

    readonly accept?: string
}

/**
 * Request parameters for authorizationsUpdate operation in DefaultApi.
 */
export interface DefaultApiAuthorizationsUpdateRequest {
    /**
     * Authorization ID
     */
    readonly authorizationId: string

    readonly accept?: string

    readonly contentType?: string

    readonly authorizationsUpdateRequest?: AuthorizationsUpdateRequest
}

/**
 * Request parameters for changesetsClose operation in DefaultApi.
 */
export interface DefaultApiChangesetsCloseRequest {
    /**
     * Changeset ID
     */
    readonly changesetId: string

    readonly accept?: string

    readonly contentType?: string
}

/**
 * Request parameters for changesetsCreate operation in DefaultApi.
 */
export interface DefaultApiChangesetsCreateRequest {
    readonly accept?: string

    readonly contentType?: string

    readonly changesetsCreateRequest?: ChangesetsCreateRequest
}

/**
 * Request parameters for changesetsGetAll operation in DefaultApi.
 */
export interface DefaultApiChangesetsGetAllRequest {
    /**
     * The page number requested
     */
    readonly page?: number

    /**
     * Number of items per page
     */
    readonly perPage?: number

    readonly accept?: string
}

/**
 * Request parameters for changesetsGetSingle operation in DefaultApi.
 */
export interface DefaultApiChangesetsGetSingleRequest {
    /**
     * Changeset ID
     */
    readonly changesetId: string

    readonly accept?: string
}

/**
 * Request parameters for changesetsUpdate operation in DefaultApi.
 */
export interface DefaultApiChangesetsUpdateRequest {
    /**
     * Changeset ID
     */
    readonly changesetId: string

    readonly accept?: string

    readonly contentType?: string

    readonly changesetsUpdateRequest?: ChangesetsUpdateRequest
}

/**
 * Request parameters for choiceListsCreate operation in DefaultApi.
 */
export interface DefaultApiChoiceListsCreateRequest {
    readonly accept?: string

    readonly contentType?: string

    readonly choiceListsCreateRequest?: ChoiceListsCreateRequest
}

/**
 * Request parameters for choiceListsDelete operation in DefaultApi.
 */
export interface DefaultApiChoiceListsDeleteRequest {
    /**
     * Choice List ID
     */
    readonly choiceListId: string

    readonly accept?: string
}

/**
 * Request parameters for choiceListsGetAll operation in DefaultApi.
 */
export interface DefaultApiChoiceListsGetAllRequest {
    /**
     * The page number requested
     */
    readonly page?: number

    /**
     * Number of items per page
     */
    readonly perPage?: number

    readonly accept?: string
}

/**
 * Request parameters for choiceListsGetSingle operation in DefaultApi.
 */
export interface DefaultApiChoiceListsGetSingleRequest {
    /**
     * Choice List ID
     */
    readonly choiceListId: string

    readonly accept?: string
}

/**
 * Request parameters for choiceListsUpdate operation in DefaultApi.
 */
export interface DefaultApiChoiceListsUpdateRequest {
    /**
     * Choice List ID
     */
    readonly choiceListId: string

    readonly accept?: string

    readonly contentType?: string

    readonly choiceListsUpdateRequest?: ChoiceListsUpdateRequest
}

/**
 * Request parameters for classificationSetsCreate operation in DefaultApi.
 */
export interface DefaultApiClassificationSetsCreateRequest {
    readonly accept?: string

    readonly contentType?: string

    readonly classificationSetsCreateRequest?: ClassificationSetsCreateRequest
}

/**
 * Request parameters for classificationSetsDelete operation in DefaultApi.
 */
export interface DefaultApiClassificationSetsDeleteRequest {
    /**
     * Classification Set ID
     */
    readonly classificationSetId: string

    readonly accept?: string
}

/**
 * Request parameters for classificationSetsGetAll operation in DefaultApi.
 */
export interface DefaultApiClassificationSetsGetAllRequest {
    /**
     * The page number requested
     */
    readonly page?: number

    /**
     * Number of items per page
     */
    readonly perPage?: number

    readonly accept?: string

    /**
     * Type of classification sets to return
     */
    readonly type?: ClassificationSetsGetAllTypeEnum
}

/**
 * Request parameters for classificationSetsGetSingle operation in DefaultApi.
 */
export interface DefaultApiClassificationSetsGetSingleRequest {
    /**
     * Classification Set ID
     */
    readonly classificationSetId: string

    readonly accept?: string
}

/**
 * Request parameters for classificationSetsUpdate operation in DefaultApi.
 */
export interface DefaultApiClassificationSetsUpdateRequest {
    /**
     * Classification Set ID
     */
    readonly classificationSetId: string

    readonly accept?: string

    readonly contentType?: string

    readonly classificationSetsUpdateRequest?: ClassificationSetsUpdateRequest
}

/**
 * Request parameters for createAttachment operation in DefaultApi.
 */
export interface DefaultApiCreateAttachmentRequest {
    /**
     * API Token. Required to authenticate the request.
     */
    readonly xApitoken?: string

    readonly createAttachmentRequest?: CreateAttachmentRequest
}

/**
 * Request parameters for createBatch operation in DefaultApi.
 */
export interface DefaultApiCreateBatchRequest {
    readonly createBatchRequest?: CreateBatchRequest
}

/**
 * Request parameters for createGroup operation in DefaultApi.
 */
export interface DefaultApiCreateGroupRequest {
    readonly accept?: string

    readonly contentType?: string

    readonly createGroupRequest?: CreateGroupRequest
}

/**
 * Request parameters for createMember operation in DefaultApi.
 */
export interface DefaultApiCreateMemberRequest {
    readonly accept?: string

    readonly contentType?: string

    readonly createMemberRequest?: CreateMemberRequest
}

/**
 * Request parameters for createReportTemplate operation in DefaultApi.
 */
export interface DefaultApiCreateReportTemplateRequest {
    readonly createReportTemplateRequest?: CreateReportTemplateRequest
}

/**
 * Request parameters for createWorkflow operation in DefaultApi.
 */
export interface DefaultApiCreateWorkflowRequest {
    readonly accept?: string

    readonly contentTyoe?: string

    readonly createWorkflowRequest?: CreateWorkflowRequest
}

/**
 * Request parameters for deleteAttachment operation in DefaultApi.
 */
export interface DefaultApiDeleteAttachmentRequest {
    /**
     * The attachment\&#39;s ID
     */
    readonly attachmentId: string

    /**
     * API Token. Required to authenticate the request.
     */
    readonly xApitoken?: string
}

/**
 * Request parameters for deleteGroup operation in DefaultApi.
 */
export interface DefaultApiDeleteGroupRequest {
    /**
     * ID of the group
     */
    readonly groupId: string

    readonly accept?: string
}

/**
 * Request parameters for deleteMember operation in DefaultApi.
 */
export interface DefaultApiDeleteMemberRequest {
    /**
     * The ID of the member
     */
    readonly membershipId: string

    readonly deleteMemberRequest?: DeleteMemberRequest
}

/**
 * Request parameters for deleteReportTemplate operation in DefaultApi.
 */
export interface DefaultApiDeleteReportTemplateRequest {
    /**
     * The id of the report
     */
    readonly id: string
}

/**
 * Request parameters for deleteWorkflow operation in DefaultApi.
 */
export interface DefaultApiDeleteWorkflowRequest {
    /**
     * The ID of the workflow
     */
    readonly workflowId: string

    readonly accept?: string
}

/**
 * Request parameters for finalizeAttachment operation in DefaultApi.
 */
export interface DefaultApiFinalizeAttachmentRequest {
    /**
     * API Token. Required to authenticate the request.
     */
    readonly xApitoken?: string

    readonly finalizeAttachmentRequest?: FinalizeAttachmentRequest
}

/**
 * Request parameters for formsCreate operation in DefaultApi.
 */
export interface DefaultApiFormsCreateRequest {
    readonly accept?: string

    readonly contentType?: string

    readonly formsCreateRequest?: FormsCreateRequest
}

/**
 * Request parameters for formsDelete operation in DefaultApi.
 */
export interface DefaultApiFormsDeleteRequest {
    /**
     * Form ID
     */
    readonly formId: string

    readonly accept?: string
}

/**
 * Request parameters for formsGetAll operation in DefaultApi.
 */
export interface DefaultApiFormsGetAllRequest {
    /**
     * schema&#x3D;false will only return the form metadata
     */
    readonly schema?: boolean

    /**
     * The page number requested
     */
    readonly page?: number

    /**
     * Number of items per page
     */
    readonly perPage?: number

    readonly accept?: string

    /**
     * Types of forms to return
     */
    readonly type?: FormsGetAllTypeEnum
}

/**
 * Request parameters for formsGetHistory operation in DefaultApi.
 */
export interface DefaultApiFormsGetHistoryRequest {
    /**
     * Form ID
     */
    readonly formId: string

    /**
     * The form history version
     */
    readonly version?: number

    /**
     * The page number requested
     */
    readonly page?: number

    /**
     * Number of items per page
     */
    readonly perPage?: number

    readonly accept?: string
}

/**
 * Request parameters for formsGetSingle operation in DefaultApi.
 */
export interface DefaultApiFormsGetSingleRequest {
    /**
     * Form ID
     */
    readonly formId: string

    readonly accept?: string

    /**
     * schema&#x3D;false will only return the form metadata
     */
    readonly schema?: boolean
}

/**
 * Request parameters for formsUpdate operation in DefaultApi.
 */
export interface DefaultApiFormsUpdateRequest {
    /**
     * Form ID
     */
    readonly formId: string

    readonly accept?: string

    readonly contentType?: string

    readonly formsUpdateRequest?: FormsUpdateRequest
}

/**
 * Request parameters for getAllAttachments operation in DefaultApi.
 */
export interface DefaultApiGetAllAttachmentsRequest {
    /**
     * The ID of the record with which the attachment is associated. This is required when listing record attachments.
     */
    readonly recordId?: string

    /**
     * The ID of the form with which the attachment is associated. This parameter will allow you to get all reference files within a form, NOT all of the record attachments in a form
     */
    readonly formId?: string

    /**
     * The type of attachment to query for. Must be either &#x60;form&#x60; or &#x60;record&#x60;.
     */
    readonly ownerType?: string

    /**
     * API Token. Required to authenticate the request.
     */
    readonly xApitoken?: string
}

/**
 * Request parameters for getAllBatches operation in DefaultApi.
 */
export interface DefaultApiGetAllBatchesRequest {
    readonly page?: string

    readonly perPage?: string

    readonly sort?: string

    /**
     * One of DESC for descending or ASC for ascending
     */
    readonly sortDirection?: string
}

/**
 * Request parameters for getAllGroups operation in DefaultApi.
 */
export interface DefaultApiGetAllGroupsRequest {
    readonly page?: string

    readonly perPage?: string

    /**
     * Set to &#x60;true&#x60; in order to see each group\&#39;s assigned &#x60;member_ids&#x60;, &#x60;layer_ids&#x60;, &#x60;project_ids&#x60; and &#x60;form_ids&#x60;
     */
    readonly associations?: boolean
}

/**
 * Request parameters for getAllMemberships operation in DefaultApi.
 */
export interface DefaultApiGetAllMembershipsRequest {
    /**
     * The type of permission (member_forms, member_layers, member_projects, form_members, layer_members, or project_members)
     */
    readonly type: string

    /**
     * The membership_id of the user or the id of the form, layer or project
     */
    readonly objectId: string

    /**
     * The page number requested
     */
    readonly page?: number

    /**
     * Number of items per page
     */
    readonly perPage?: number

    readonly accept?: string
}

/**
 * Request parameters for getAllReportTemplates operation in DefaultApi.
 */
export interface DefaultApiGetAllReportTemplatesRequest {
    /**
     * The page number requested
     */
    readonly page?: number

    /**
     * Number of items per page
     */
    readonly perPage?: number

    /**
     * The form to fetch reports for
     */
    readonly formId?: string
}

/**
 * Request parameters for getAllWorkflows operation in DefaultApi.
 */
export interface DefaultApiGetAllWorkflowsRequest {
    /**
     * The page number requested
     */
    readonly page?: number

    /**
     * Number of items per page
     */
    readonly perPage?: number

    readonly accept?: string
}

/**
 * Request parameters for getGroupResource operation in DefaultApi.
 */
export interface DefaultApiGetGroupResourceRequest {
    /**
     * Group ID
     */
    readonly groupId: string

    /**
     * One of &#x60;members&#x60;, &#x60;projects&#x60;, &#x60;layers&#x60; or &#x60;forms&#x60;
     */
    readonly resource: string

    readonly accept?: string

    /**
     * Page of the response
     */
    readonly page?: number

    /**
     * Amount of items in every page
     */
    readonly perPage?: number
}

/**
 * Request parameters for getSingleAttachment operation in DefaultApi.
 */
export interface DefaultApiGetSingleAttachmentRequest {
    /**
     * The attachment id.
     */
    readonly attachmentId: string

    /**
     * API Token. Required to authenticate the request.
     */
    readonly xApitoken?: string
}

/**
 * Request parameters for getSingleBatch operation in DefaultApi.
 */
export interface DefaultApiGetSingleBatchRequest {
    /**
     * The ID of the batch
     */
    readonly batchId: string

    readonly page?: string

    readonly perPage?: string
}

/**
 * Request parameters for getSingleGroup operation in DefaultApi.
 */
export interface DefaultApiGetSingleGroupRequest {
    /**
     * Group ID
     */
    readonly groupId: string

    readonly accept?: string

    /**
     * Set to &#x60;true&#x60; in order to see each group\&#39;s assigned &#x60;member_ids&#x60;, &#x60;layer_ids&#x60;, &#x60;project_ids&#x60; and &#x60;form_ids&#x60;
     */
    readonly associations?: boolean
}

/**
 * Request parameters for getSingleReportTemplate operation in DefaultApi.
 */
export interface DefaultApiGetSingleReportTemplateRequest {
    /**
     * The id of the report
     */
    readonly id: string
}

/**
 * Request parameters for getSingleWorkflow operation in DefaultApi.
 */
export interface DefaultApiGetSingleWorkflowRequest {
    /**
     * The id of the workflow
     */
    readonly workflowId: string

    readonly accept?: string
}

/**
 * Request parameters for layersCreate operation in DefaultApi.
 */
export interface DefaultApiLayersCreateRequest {
    readonly accept?: string

    readonly contentType?: string

    readonly layersCreateRequest?: LayersCreateRequest
}

/**
 * Request parameters for layersDelete operation in DefaultApi.
 */
export interface DefaultApiLayersDeleteRequest {
    /**
     * Layer ID
     */
    readonly layerId: string

    readonly accept?: string
}

/**
 * Request parameters for layersGetAll operation in DefaultApi.
 */
export interface DefaultApiLayersGetAllRequest {
    /**
     * The page number requested
     */
    readonly page?: number

    /**
     * Number of items per page
     */
    readonly perPage?: number

    readonly accept?: string
}

/**
 * Request parameters for layersGetSingle operation in DefaultApi.
 */
export interface DefaultApiLayersGetSingleRequest {
    /**
     * Layer ID
     */
    readonly layerId: string

    readonly accept?: string
}

/**
 * Request parameters for layersUpdate operation in DefaultApi.
 */
export interface DefaultApiLayersUpdateRequest {
    /**
     * Layer ID
     */
    readonly layerId: string

    readonly accept?: string

    readonly contentType?: string

    readonly layersUpdateRequest?: LayersUpdateRequest
}

/**
 * Request parameters for membershipsChangePermissions operation in DefaultApi.
 */
export interface DefaultApiMembershipsChangePermissionsRequest {
    readonly accept?: string

    readonly contentType?: string

    readonly membershipsChangePermissionsRequest?: MembershipsChangePermissionsRequest
}

/**
 * Request parameters for membershipsGetAll operation in DefaultApi.
 */
export interface DefaultApiMembershipsGetAllRequest {
    /**
     * Limit members to a specific Form
     */
    readonly formId?: string

    /**
     * Limit members to a specific Project
     */
    readonly projectId?: string

    /**
     * Limit members to a specific Layer
     */
    readonly layerId?: string

    /**
     * The page number requested
     */
    readonly page?: number

    /**
     * Number of items per page
     */
    readonly perPage?: number

    readonly accept?: string
}

/**
 * Request parameters for membershipsGetSingle operation in DefaultApi.
 */
export interface DefaultApiMembershipsGetSingleRequest {
    /**
     * Membership ID
     */
    readonly membershipId: string

    readonly accept?: string
}

/**
 * Request parameters for photosGetAllMetadata operation in DefaultApi.
 */
export interface DefaultApiPhotosGetAllMetadataRequest {
    /**
     * The ID of the record with which the photo is associated.
     */
    readonly recordId?: string

    /**
     * The ID of the form with which the photo is associated. Leaving this blank will query against all of your photos.
     */
    readonly formId?: string

    /**
     * If present, photos will be sorted by updated_at date.
     */
    readonly newestFirst?: boolean

    /**
     * Photo has been completely processed.
     */
    readonly processed?: boolean

    /**
     * Photo has been completely stored.
     */
    readonly stored?: boolean

    /**
     * Photo has been completely uploaded.
     */
    readonly uploaded?: boolean

    /**
     * The page number requested
     */
    readonly page?: number

    /**
     * Number of items per page
     */
    readonly perPage?: number

    readonly accept?: string
}

/**
 * Request parameters for photosGetSingleFile operation in DefaultApi.
 */
export interface DefaultApiPhotosGetSingleFileRequest {
    /**
     * Photo ID
     */
    readonly photoId: string

    readonly accept?: string
}

/**
 * Request parameters for photosGetSingleMetadata operation in DefaultApi.
 */
export interface DefaultApiPhotosGetSingleMetadataRequest {
    /**
     * Photo ID
     */
    readonly photoId: string

    readonly accept?: string
}

/**
 * Request parameters for photosLargeFile operation in DefaultApi.
 */
export interface DefaultApiPhotosLargeFileRequest {
    /**
     * Photo ID
     */
    readonly photoId: string

    readonly accept?: string
}

/**
 * Request parameters for photosLargeMetadata operation in DefaultApi.
 */
export interface DefaultApiPhotosLargeMetadataRequest {
    /**
     * Photo ID
     */
    readonly photoId: string

    readonly accept?: string
}

/**
 * Request parameters for photosThumbnailFile operation in DefaultApi.
 */
export interface DefaultApiPhotosThumbnailFileRequest {
    /**
     * Photo ID
     */
    readonly photoId: string

    readonly accept?: string
}

/**
 * Request parameters for photosThumbnailMetadata operation in DefaultApi.
 */
export interface DefaultApiPhotosThumbnailMetadataRequest {
    /**
     * Photo ID
     */
    readonly photoId: string

    readonly accept?: string
}

/**
 * Request parameters for photosUpload operation in DefaultApi.
 */
export interface DefaultApiPhotosUploadRequest {
    readonly accept?: string

    readonly contentType?: string
}

/**
 * Request parameters for projectsCreate operation in DefaultApi.
 */
export interface DefaultApiProjectsCreateRequest {
    readonly accept?: string

    readonly contentType?: string

    readonly projectsCreateRequest?: ProjectsCreateRequest
}

/**
 * Request parameters for projectsDelete operation in DefaultApi.
 */
export interface DefaultApiProjectsDeleteRequest {
    /**
     * Project ID
     */
    readonly projectId: string

    readonly accept?: string
}

/**
 * Request parameters for projectsGetAll operation in DefaultApi.
 */
export interface DefaultApiProjectsGetAllRequest {
    /**
     * The page number requested
     */
    readonly page?: number

    /**
     * Number of items per page
     */
    readonly perPage?: number

    readonly accept?: string
}

/**
 * Request parameters for projectsGetSingle operation in DefaultApi.
 */
export interface DefaultApiProjectsGetSingleRequest {
    /**
     * Project ID
     */
    readonly projectId: string

    readonly accept?: string
}

/**
 * Request parameters for projectsUpdate operation in DefaultApi.
 */
export interface DefaultApiProjectsUpdateRequest {
    /**
     * Project ID
     */
    readonly projectId: string

    readonly accept?: string

    readonly contentType?: string

    readonly projectsUpdateRequest?: ProjectsUpdateRequest
}

/**
 * Request parameters for queryGet operation in DefaultApi.
 */
export interface DefaultApiQueryGetRequest {
    /**
     * The SQL query
     */
    readonly q: string

    /**
     * The format of the results returned by the query. Options include &#x60;csv&#x60;, &#x60;json&#x60;, &#x60;geojson&#x60;, &#x60;postgres&#x60;.
     */
    readonly format?: string

    /**
     * Include headers for csv format?
     */
    readonly headers?: boolean

    /**
     * Include column metadata for &#x60;json&#x60; format?
     */
    readonly metadata?: boolean

    /**
     * Return row arrays instead of objects for &#x60;json&#x60; format?
     */
    readonly arrays?: boolean

    /**
     * Table name for &#x60;postgres&#x60; format. Defaults to query.
     */
    readonly tableName?: string

    /**
     * The name of the column used to sort on.
     */
    readonly sortColumn?: string

    /**
     * The sort direction (asc, desc).
     */
    readonly sortDirection?: string

    /**
     * The page number requested
     */
    readonly page?: number

    /**
     * Number of items per page
     */
    readonly perPage?: number

    readonly accept?: string

    readonly userAgent?: string
}

/**
 * Request parameters for queryPost operation in DefaultApi.
 */
export interface DefaultApiQueryPostRequest {
    /**
     * The page number requested
     */
    readonly page?: number

    /**
     * Number of items per page
     */
    readonly perPage?: number

    readonly accept?: string

    readonly queryPostRequest?: QueryPostRequest
}

/**
 * Request parameters for recordsCreate operation in DefaultApi.
 */
export interface DefaultApiRecordsCreateRequest {
    readonly accept?: string

    readonly contentType?: string

    /**
     * Skips all app workflows
     */
    readonly xSkipWorkflows?: boolean

    /**
     * Skips all app webhooks
     */
    readonly xSkipWebhooks?: boolean

    readonly recordsCreateRequest?: RecordsCreateRequest
}

/**
 * Request parameters for recordsDelete operation in DefaultApi.
 */
export interface DefaultApiRecordsDeleteRequest {
    /**
     * Record ID
     */
    readonly recordId: string

    readonly accept?: string

    /**
     * Skips all app workflows
     */
    readonly xSkipWorkflows?: boolean

    /**
     * Skips all app webhooks
     */
    readonly xSkipWebhooks?: boolean
}

/**
 * Request parameters for recordsGetAll operation in DefaultApi.
 */
export interface DefaultApiRecordsGetAllRequest {
    /**
     * If present, records will be sorted by updated_at date.
     */
    readonly newestFirst?: boolean

    /**
     * Bounding box of the records requested. Format should be: lat,long,lat,long (bottom, left, top, right).
     */
    readonly boundingBox?: string

    /**
     * The id of the changeset associated with the record.
     */
    readonly changesetId?: string

    /**
     * The id of the form with which the record is associated. Leaving this blank will query against all of your records.
     */
    readonly formId?: string

    /**
     * The id of the project with which the record is associated. Leaving this blank will query against all of your records.
     */
    readonly projectId?: string

    /**
     * Return only records which were created by the client (device) before the given time.
     */
    readonly clientCreatedBefore?: string

    /**
     * Return only records which were created by the client (device) after the given time.
     */
    readonly clientCreatedSince?: string

    /**
     * Return only records which were updated by the client (device) before the given time.
     */
    readonly clientUpdatedBefore?: string

    /**
     * Return only records which were updated by the client (device) after the given time.
     */
    readonly clientUpdatedSince?: string

    /**
     * Return only records which were created (on the server) before the given time.
     */
    readonly createdBefore?: string

    /**
     * Return only records which were created (on the server) after the given time.
     */
    readonly createdSince?: string

    /**
     * Return only records which were updated (on the server) before the given time.
     */
    readonly updatedBefore?: string

    /**
     * Return only records which were updated (on the server) after the given time.
     */
    readonly updatedSince?: string

    /**
     * The page number requested
     */
    readonly page?: number

    /**
     * Number of items per page
     */
    readonly perPage?: number

    readonly accept?: string
}

/**
 * Request parameters for recordsGetAllHistory operation in DefaultApi.
 */
export interface DefaultApiRecordsGetAllHistoryRequest {
    readonly accept?: string

    readonly changesetId?: string

    readonly deletedFormId?: string
}

/**
 * Request parameters for recordsGetHistory operation in DefaultApi.
 */
export interface DefaultApiRecordsGetHistoryRequest {
    /**
     * Record ID
     */
    readonly recordId: string

    readonly accept?: string
}

/**
 * Request parameters for recordsGetSingle operation in DefaultApi.
 */
export interface DefaultApiRecordsGetSingleRequest {
    /**
     * Record ID
     */
    readonly recordId: string

    readonly accept?: string
}

/**
 * Request parameters for recordsUpdate operation in DefaultApi.
 */
export interface DefaultApiRecordsUpdateRequest {
    /**
     * Record ID
     */
    readonly recordId: string

    readonly accept?: string

    readonly contentType?: string

    /**
     * Skips all app workflows
     */
    readonly xSkipWorkflows?: boolean

    /**
     * Skips all app webhooks
     */
    readonly xSkipWebhooks?: boolean

    readonly recordsUpdateRequest?: RecordsUpdateRequest
}

/**
 * Request parameters for rolesGetAll operation in DefaultApi.
 */
export interface DefaultApiRolesGetAllRequest {
    /**
     * The page number requested
     */
    readonly page?: number

    /**
     * Number of items per page
     */
    readonly perPage?: number

    readonly accept?: string

    /**
     * Sort by role name. Default sort is by &#x60;updated_at&#x60; if sort is not provided
     */
    readonly sort?: string

    /**
     * The sort direction (asc, desc). Default is &#x60;asc&#x60;
     */
    readonly sortDirection?: string
}

/**
 * Request parameters for signaturesGetAll operation in DefaultApi.
 */
export interface DefaultApiSignaturesGetAllRequest {
    /**
     * The ID of the record with which the photo is associated.
     */
    readonly recordId?: string

    /**
     * The ID of the form with which the photo is associated. Leaving this blank will query against all of your photos.
     */
    readonly formId?: string

    /**
     * If present, photos will be sorted by updated_at date.
     */
    readonly newestFirst?: boolean

    /**
     * Signature has been completely processed.
     */
    readonly processed?: boolean

    /**
     * Signature has been completely stored.
     */
    readonly stored?: boolean

    /**
     * Signature has been completely uploaded.
     */
    readonly uploaded?: boolean

    /**
     * The page number requested
     */
    readonly page?: number

    /**
     * Number of items per page
     */
    readonly perPage?: number

    readonly accept?: string
}

/**
 * Request parameters for signaturesGetSingleFile operation in DefaultApi.
 */
export interface DefaultApiSignaturesGetSingleFileRequest {
    /**
     * Signature ID
     */
    readonly signatureId: string

    readonly accept?: string
}

/**
 * Request parameters for signaturesGetSingleMetadata operation in DefaultApi.
 */
export interface DefaultApiSignaturesGetSingleMetadataRequest {
    /**
     * Signature ID
     */
    readonly signatureId: string

    readonly accept?: string
}

/**
 * Request parameters for signaturesGetThumbnailFile operation in DefaultApi.
 */
export interface DefaultApiSignaturesGetThumbnailFileRequest {
    /**
     * Signature ID
     */
    readonly signatureId: string

    readonly accept?: string
}

/**
 * Request parameters for signaturesGetThumbnailMetadata operation in DefaultApi.
 */
export interface DefaultApiSignaturesGetThumbnailMetadataRequest {
    /**
     * Signature ID
     */
    readonly signatureId: string

    readonly accept?: string
}

/**
 * Request parameters for signaturesUpload operation in DefaultApi.
 */
export interface DefaultApiSignaturesUploadRequest {
    readonly accept?: string

    readonly contentType?: string
}

/**
 * Request parameters for startBatch operation in DefaultApi.
 */
export interface DefaultApiStartBatchRequest {
    /**
     * ID of the batch
     */
    readonly batchId: string
}

/**
 * Request parameters for updateGroupNameDescription operation in DefaultApi.
 */
export interface DefaultApiUpdateGroupNameDescriptionRequest {
    /**
     * ID of the group
     */
    readonly groupId: string

    readonly accept?: string

    readonly contentType?: string

    readonly updateGroupNameDescriptionRequest?: UpdateGroupNameDescriptionRequest
}

/**
 * Request parameters for updateGroupPermissions operation in DefaultApi.
 */
export interface DefaultApiUpdateGroupPermissionsRequest {
    readonly accept?: string

    readonly contentType?: string

    readonly updateGroupPermissionsRequest?: UpdateGroupPermissionsRequest
}

/**
 * Request parameters for updateMember operation in DefaultApi.
 */
export interface DefaultApiUpdateMemberRequest {
    /**
     * The ID of the member
     */
    readonly membershipId: string

    readonly updateMemberRequest?: UpdateMemberRequest
}

/**
 * Request parameters for updateReportTemplate operation in DefaultApi.
 */
export interface DefaultApiUpdateReportTemplateRequest {
    /**
     * The id of the report
     */
    readonly id: string

    readonly updateReportTemplateRequest?: UpdateReportTemplateRequest
}

/**
 * Request parameters for updateWorkflow operation in DefaultApi.
 */
export interface DefaultApiUpdateWorkflowRequest {
    /**
     * The ID of the workflow
     */
    readonly workflowId: string

    readonly accept?: string

    readonly contentTyoe?: string

    readonly updateWorkflowRequest?: UpdateWorkflowRequest
}

/**
 * Request parameters for usersGetUser operation in DefaultApi.
 */
export interface DefaultApiUsersGetUserRequest {
    /**
     * The page number requested
     */
    readonly page?: number

    /**
     * Number of items per page
     */
    readonly perPage?: number

    readonly accept?: string
}

/**
 * Request parameters for videosGetAll operation in DefaultApi.
 */
export interface DefaultApiVideosGetAllRequest {
    /**
     * The ID of the record with which the video is associated.
     */
    readonly recordId?: string

    /**
     * The ID of the form with which the video is associated. Leaving this blank will query against all of your videos.
     */
    readonly formId?: string

    /**
     * If present, videos will be sorted by updated_at date.
     */
    readonly newestFirst?: boolean

    /**
     * Video has been completely processed.
     */
    readonly processed?: boolean

    /**
     * Video has been completely stored.
     */
    readonly stored?: boolean

    /**
     * Video has been completely uploaded.
     */
    readonly uploaded?: boolean

    /**
     * The page number requested
     */
    readonly page?: number

    /**
     * Number of items per page
     */
    readonly perPage?: number

    readonly accept?: string
}

/**
 * Request parameters for videosGetAllTracksGeojson operation in DefaultApi.
 */
export interface DefaultApiVideosGetAllTracksGeojsonRequest {
    readonly accept?: string

    /**
     * Set value to &#x60;points&#x60; to fetch tracks as GeoJSON points
     */
    readonly type?: string
}

/**
 * Request parameters for videosGetAllTracksGpx operation in DefaultApi.
 */
export interface DefaultApiVideosGetAllTracksGpxRequest {
    readonly accept?: string
}

/**
 * Request parameters for videosGetAllTracksKml operation in DefaultApi.
 */
export interface DefaultApiVideosGetAllTracksKmlRequest {
    readonly accept?: string
}

/**
 * Request parameters for videosGetMediumFile operation in DefaultApi.
 */
export interface DefaultApiVideosGetMediumFileRequest {
    /**
     * Video ID
     */
    readonly videoId: string

    readonly accept?: string
}

/**
 * Request parameters for videosGetOriginalFile operation in DefaultApi.
 */
export interface DefaultApiVideosGetOriginalFileRequest {
    /**
     * Video ID
     */
    readonly videoId: string

    readonly accept?: string
}

/**
 * Request parameters for videosGetSingleMetadata operation in DefaultApi.
 */
export interface DefaultApiVideosGetSingleMetadataRequest {
    /**
     * Video ID
     */
    readonly videoId: string

    readonly accept?: string
}

/**
 * Request parameters for videosGetSingleTrackGeojson operation in DefaultApi.
 */
export interface DefaultApiVideosGetSingleTrackGeojsonRequest {
    /**
     * Video ID
     */
    readonly videoId: string

    readonly accept?: string

    /**
     * Set value to &#x60;points&#x60; to fetch tracks as GeoJSON points
     */
    readonly type?: string
}

/**
 * Request parameters for videosGetSingleTrackGpx operation in DefaultApi.
 */
export interface DefaultApiVideosGetSingleTrackGpxRequest {
    /**
     * Video ID
     */
    readonly videoId: string

    readonly accept?: string
}

/**
 * Request parameters for videosGetSingleTrackJson operation in DefaultApi.
 */
export interface DefaultApiVideosGetSingleTrackJsonRequest {
    /**
     * Video ID
     */
    readonly videoId: string

    readonly accept?: string
}

/**
 * Request parameters for videosGetSingleTrackKml operation in DefaultApi.
 */
export interface DefaultApiVideosGetSingleTrackKmlRequest {
    /**
     * Video ID
     */
    readonly videoId: string

    readonly accept?: string
}

/**
 * Request parameters for videosGetSmallFile operation in DefaultApi.
 */
export interface DefaultApiVideosGetSmallFileRequest {
    /**
     * Video ID
     */
    readonly videoId: string

    readonly accept?: string
}

/**
 * Request parameters for videosGetThumbnailHuge operation in DefaultApi.
 */
export interface DefaultApiVideosGetThumbnailHugeRequest {
    /**
     * Video ID
     */
    readonly videoId: string

    readonly accept?: string
}

/**
 * Request parameters for videosGetThumbnailHugeSquare operation in DefaultApi.
 */
export interface DefaultApiVideosGetThumbnailHugeSquareRequest {
    /**
     * Video ID
     */
    readonly videoId: string

    readonly accept?: string
}

/**
 * Request parameters for videosGetThumbnailLarge operation in DefaultApi.
 */
export interface DefaultApiVideosGetThumbnailLargeRequest {
    /**
     * Video ID
     */
    readonly videoId: string

    readonly accept?: string
}

/**
 * Request parameters for videosGetThumbnailLargeSquare operation in DefaultApi.
 */
export interface DefaultApiVideosGetThumbnailLargeSquareRequest {
    /**
     * Video ID
     */
    readonly videoId: string

    readonly accept?: string
}

/**
 * Request parameters for videosGetThumbnailMedium operation in DefaultApi.
 */
export interface DefaultApiVideosGetThumbnailMediumRequest {
    /**
     * Video ID
     */
    readonly videoId: string

    readonly accept?: string
}

/**
 * Request parameters for videosGetThumbnailMediumSquare operation in DefaultApi.
 */
export interface DefaultApiVideosGetThumbnailMediumSquareRequest {
    /**
     * Video ID
     */
    readonly videoId: string

    readonly accept?: string
}

/**
 * Request parameters for videosGetThumbnailSmall operation in DefaultApi.
 */
export interface DefaultApiVideosGetThumbnailSmallRequest {
    /**
     * Video ID
     */
    readonly videoId: string

    readonly accept?: string
}

/**
 * Request parameters for videosGetThumbnailSmallSquare operation in DefaultApi.
 */
export interface DefaultApiVideosGetThumbnailSmallSquareRequest {
    /**
     * Video ID
     */
    readonly videoId: string

    readonly accept?: string
}

/**
 * Request parameters for videosUpload operation in DefaultApi.
 */
export interface DefaultApiVideosUploadRequest {
    readonly accept?: string

    readonly contentType?: string
}

/**
 * Request parameters for webhooksCreate operation in DefaultApi.
 */
export interface DefaultApiWebhooksCreateRequest {
    readonly accept?: string

    readonly contentType?: string

    readonly webhooksCreateRequest?: WebhooksCreateRequest
}

/**
 * Request parameters for webhooksDelete operation in DefaultApi.
 */
export interface DefaultApiWebhooksDeleteRequest {
    /**
     * Webhook ID
     */
    readonly webhookId: string

    readonly accept?: string
}

/**
 * Request parameters for webhooksGetAll operation in DefaultApi.
 */
export interface DefaultApiWebhooksGetAllRequest {
    /**
     * The page number requested
     */
    readonly page?: number

    /**
     * Number of items per page
     */
    readonly perPage?: number

    readonly accept?: string
}

/**
 * Request parameters for webhooksGetSingle operation in DefaultApi.
 */
export interface DefaultApiWebhooksGetSingleRequest {
    /**
     * Webhook ID
     */
    readonly webhookId: string

    readonly accept?: string
}

/**
 * Request parameters for webhooksUpdate operation in DefaultApi.
 */
export interface DefaultApiWebhooksUpdateRequest {
    /**
     * Webhook ID
     */
    readonly webhookId: string

    readonly accept?: string

    readonly contentType?: string

    readonly webhooksUpdateRequest?: WebhooksUpdateRequest
}

/**
 * DefaultApi - object-oriented interface
 */
export class DefaultApi extends BaseAPI implements DefaultApiInterface {
    /**
     * Using the batch operations API, you can bulk delete records from a form or update project, assignee, or status values on multiple records.
     * @summary Add batch operations
     * @param {DefaultApiAddBatchOperationsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public addBatchOperations(requestParameters: DefaultApiAddBatchOperationsRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).addBatchOperations(requestParameters.batchId, requestParameters.addBatchOperationsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get All Audio
     * @param {DefaultApiAudioGetAllRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public audioGetAll(requestParameters: DefaultApiAudioGetAllRequest = {}, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).audioGetAll(requestParameters.recordId, requestParameters.formId, requestParameters.newestFirst, requestParameters.processed, requestParameters.stored, requestParameters.uploaded, requestParameters.page, requestParameters.perPage, requestParameters.accept, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get GeoJSON Tracks for All Audio
     * @param {DefaultApiAudioGetAllTracksGeojsonRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public audioGetAllTracksGeojson(requestParameters: DefaultApiAudioGetAllTracksGeojsonRequest = {}, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).audioGetAllTracksGeojson(requestParameters.accept, requestParameters.type, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get GPX Tracks for All Audio
     * @param {DefaultApiAudioGetAllTracksGpxRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public audioGetAllTracksGpx(requestParameters: DefaultApiAudioGetAllTracksGpxRequest = {}, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).audioGetAllTracksGpx(requestParameters.accept, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get JSON Tracks for All Audio
     * @param {DefaultApiAudioGetAllTracksJsonRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public audioGetAllTracksJson(requestParameters: DefaultApiAudioGetAllTracksJsonRequest = {}, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).audioGetAllTracksJson(requestParameters.accept, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get KML Tracks for All Audio
     * @param {DefaultApiAudioGetAllTracksKmlRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public audioGetAllTracksKml(requestParameters: DefaultApiAudioGetAllTracksKmlRequest = {}, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).audioGetAllTracksKml(requestParameters.accept, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Original Audio File
     * @param {DefaultApiAudioGetOriginalFileRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public audioGetOriginalFile(requestParameters: DefaultApiAudioGetOriginalFileRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).audioGetOriginalFile(requestParameters.audioId, requestParameters.accept, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Audio Metadata
     * @param {DefaultApiAudioGetSingleMetadataRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public audioGetSingleMetadata(requestParameters: DefaultApiAudioGetSingleMetadataRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).audioGetSingleMetadata(requestParameters.audioId, requestParameters.accept, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get GeoJSON Audio Track
     * @param {DefaultApiAudioGetSingleTrackGeojsonRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public audioGetSingleTrackGeojson(requestParameters: DefaultApiAudioGetSingleTrackGeojsonRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).audioGetSingleTrackGeojson(requestParameters.audioId, requestParameters.accept, requestParameters.type, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get GPX Audio Track
     * @param {DefaultApiAudioGetSingleTrackGpxRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public audioGetSingleTrackGpx(requestParameters: DefaultApiAudioGetSingleTrackGpxRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).audioGetSingleTrackGpx(requestParameters.audioId, requestParameters.accept, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get JSON Audio Track
     * @param {DefaultApiAudioGetSingleTrackJsonRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public audioGetSingleTrackJson(requestParameters: DefaultApiAudioGetSingleTrackJsonRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).audioGetSingleTrackJson(requestParameters.audioId, requestParameters.accept, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get KML Audio Track
     * @param {DefaultApiAudioGetSingleTrackKmlRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public audioGetSingleTrackKml(requestParameters: DefaultApiAudioGetSingleTrackKmlRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).audioGetSingleTrackKml(requestParameters.audioId, requestParameters.accept, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Upload audio with optional track file
     * @summary Upload Audio
     * @param {DefaultApiAudioUploadRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public audioUpload(requestParameters: DefaultApiAudioUploadRequest = {}, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).audioUpload(requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get All Audit Logs
     * @param {DefaultApiAuditLogsGetAllRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public auditLogsGetAll(requestParameters: DefaultApiAuditLogsGetAllRequest = {}, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).auditLogsGetAll(requestParameters.source, requestParameters.activity, requestParameters.ip, requestParameters.user, requestParameters.updatedSince, requestParameters.updatedBefore, requestParameters.page, requestParameters.perPage, requestParameters.accept, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Single Audit Log
     * @param {DefaultApiAuditLogsGetSingleRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public auditLogsGetSingle(requestParameters: DefaultApiAuditLogsGetSingleRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).auditLogsGetSingle(requestParameters.auditLogId, requestParameters.accept, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create Authorization
     * @param {DefaultApiAuthorizationsCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public authorizationsCreate(requestParameters: DefaultApiAuthorizationsCreateRequest = {}, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).authorizationsCreate(requestParameters.accept, requestParameters.contentType, requestParameters.authorizationsCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete Authorization
     * @param {DefaultApiAuthorizationsDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public authorizationsDelete(requestParameters: DefaultApiAuthorizationsDeleteRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).authorizationsDelete(requestParameters.authorizationId, requestParameters.accept, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get All Authorizations
     * @param {DefaultApiAuthorizationsGetAllRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public authorizationsGetAll(requestParameters: DefaultApiAuthorizationsGetAllRequest = {}, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).authorizationsGetAll(requestParameters.page, requestParameters.perPage, requestParameters.accept, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Single Authorization
     * @param {DefaultApiAuthorizationsGetSingleRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public authorizationsGetSingle(requestParameters: DefaultApiAuthorizationsGetSingleRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).authorizationsGetSingle(requestParameters.authorizationId, requestParameters.accept, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update Authorization
     * @param {DefaultApiAuthorizationsUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public authorizationsUpdate(requestParameters: DefaultApiAuthorizationsUpdateRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).authorizationsUpdate(requestParameters.authorizationId, requestParameters.accept, requestParameters.contentType, requestParameters.authorizationsUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Close Changeset
     * @param {DefaultApiChangesetsCloseRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public changesetsClose(requestParameters: DefaultApiChangesetsCloseRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).changesetsClose(requestParameters.changesetId, requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create Changeset
     * @param {DefaultApiChangesetsCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public changesetsCreate(requestParameters: DefaultApiChangesetsCreateRequest = {}, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).changesetsCreate(requestParameters.accept, requestParameters.contentType, requestParameters.changesetsCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get All Changesets
     * @param {DefaultApiChangesetsGetAllRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public changesetsGetAll(requestParameters: DefaultApiChangesetsGetAllRequest = {}, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).changesetsGetAll(requestParameters.page, requestParameters.perPage, requestParameters.accept, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Single Changeset
     * @param {DefaultApiChangesetsGetSingleRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public changesetsGetSingle(requestParameters: DefaultApiChangesetsGetSingleRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).changesetsGetSingle(requestParameters.changesetId, requestParameters.accept, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update Changeset
     * @param {DefaultApiChangesetsUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public changesetsUpdate(requestParameters: DefaultApiChangesetsUpdateRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).changesetsUpdate(requestParameters.changesetId, requestParameters.accept, requestParameters.contentType, requestParameters.changesetsUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create Choice List
     * @param {DefaultApiChoiceListsCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public choiceListsCreate(requestParameters: DefaultApiChoiceListsCreateRequest = {}, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).choiceListsCreate(requestParameters.accept, requestParameters.contentType, requestParameters.choiceListsCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete Choice List
     * @param {DefaultApiChoiceListsDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public choiceListsDelete(requestParameters: DefaultApiChoiceListsDeleteRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).choiceListsDelete(requestParameters.choiceListId, requestParameters.accept, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get All Choice Lists
     * @param {DefaultApiChoiceListsGetAllRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public choiceListsGetAll(requestParameters: DefaultApiChoiceListsGetAllRequest = {}, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).choiceListsGetAll(requestParameters.page, requestParameters.perPage, requestParameters.accept, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Single Choice List
     * @param {DefaultApiChoiceListsGetSingleRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public choiceListsGetSingle(requestParameters: DefaultApiChoiceListsGetSingleRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).choiceListsGetSingle(requestParameters.choiceListId, requestParameters.accept, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update Choice List
     * @param {DefaultApiChoiceListsUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public choiceListsUpdate(requestParameters: DefaultApiChoiceListsUpdateRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).choiceListsUpdate(requestParameters.choiceListId, requestParameters.accept, requestParameters.contentType, requestParameters.choiceListsUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create Classification Set
     * @param {DefaultApiClassificationSetsCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public classificationSetsCreate(requestParameters: DefaultApiClassificationSetsCreateRequest = {}, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).classificationSetsCreate(requestParameters.accept, requestParameters.contentType, requestParameters.classificationSetsCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete Classification Set
     * @param {DefaultApiClassificationSetsDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public classificationSetsDelete(requestParameters: DefaultApiClassificationSetsDeleteRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).classificationSetsDelete(requestParameters.classificationSetId, requestParameters.accept, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get All Classification Sets
     * @param {DefaultApiClassificationSetsGetAllRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public classificationSetsGetAll(requestParameters: DefaultApiClassificationSetsGetAllRequest = {}, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).classificationSetsGetAll(requestParameters.page, requestParameters.perPage, requestParameters.accept, requestParameters.type, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Single Classification Set
     * @param {DefaultApiClassificationSetsGetSingleRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public classificationSetsGetSingle(requestParameters: DefaultApiClassificationSetsGetSingleRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).classificationSetsGetSingle(requestParameters.classificationSetId, requestParameters.accept, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update Classification Set
     * @param {DefaultApiClassificationSetsUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public classificationSetsUpdate(requestParameters: DefaultApiClassificationSetsUpdateRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).classificationSetsUpdate(requestParameters.classificationSetId, requestParameters.accept, requestParameters.contentType, requestParameters.classificationSetsUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * There is only one parameter that is required for creating an attachment: `owners`. You must specify at least one owner of type `record` or `form`. If you create a `record` attachment you can optionally include a `name` and `file_size`. The name will be the name of the file shown in the record information. The file_size is only used for verifying that uploading this attachment will not exceed your current storage limit. If no file_size is provided the attachment may be rejected once it has been uploaded. The response will provide the `url` to upload (PUT) the file to.
     * @summary Create Attachment
     * @param {DefaultApiCreateAttachmentRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createAttachment(requestParameters: DefaultApiCreateAttachmentRequest = {}, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).createAttachment(requestParameters.xApitoken, requestParameters.createAttachmentRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Using the batch operations API, you can bulk delete records from a form.
     * @summary Create Batch to Bulk Delete Records
     * @param {DefaultApiCreateBatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createBatch(requestParameters: DefaultApiCreateBatchRequest = {}, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).createBatch(requestParameters.createBatchRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create Group
     * @param {DefaultApiCreateGroupRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createGroup(requestParameters: DefaultApiCreateGroupRequest = {}, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).createGroup(requestParameters.accept, requestParameters.contentType, requestParameters.createGroupRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create Member
     * @param {DefaultApiCreateMemberRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createMember(requestParameters: DefaultApiCreateMemberRequest = {}, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).createMember(requestParameters.accept, requestParameters.contentType, requestParameters.createMemberRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create Report Template
     * @param {DefaultApiCreateReportTemplateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createReportTemplate(requestParameters: DefaultApiCreateReportTemplateRequest = {}, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).createReportTemplate(requestParameters.createReportTemplateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create Workflow
     * @param {DefaultApiCreateWorkflowRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createWorkflow(requestParameters: DefaultApiCreateWorkflowRequest = {}, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).createWorkflow(requestParameters.accept, requestParameters.contentTyoe, requestParameters.createWorkflowRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The delete endpoint only applies to Form attachments. Use this endpoint to delete an attachment. For record attachments, simply remove the association of an attachment from the record and the attachment will be deleted.
     * @summary Delete Attachment
     * @param {DefaultApiDeleteAttachmentRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteAttachment(requestParameters: DefaultApiDeleteAttachmentRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).deleteAttachment(requestParameters.attachmentId, requestParameters.xApitoken, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete Group
     * @param {DefaultApiDeleteGroupRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteGroup(requestParameters: DefaultApiDeleteGroupRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).deleteGroup(requestParameters.groupId, requestParameters.accept, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete Member
     * @param {DefaultApiDeleteMemberRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteMember(requestParameters: DefaultApiDeleteMemberRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).deleteMember(requestParameters.membershipId, requestParameters.deleteMemberRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete Report Template
     * @param {DefaultApiDeleteReportTemplateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteReportTemplate(requestParameters: DefaultApiDeleteReportTemplateRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).deleteReportTemplate(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete Workflow
     * @param {DefaultApiDeleteWorkflowRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteWorkflow(requestParameters: DefaultApiDeleteWorkflowRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).deleteWorkflow(requestParameters.workflowId, requestParameters.accept, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The finalize endpoint is a required step for Form attachments. Use this endpoint to tell Fulcrum that your attachment has been uploaded.
     * @summary Finalize Attachment
     * @param {DefaultApiFinalizeAttachmentRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public finalizeAttachment(requestParameters: DefaultApiFinalizeAttachmentRequest = {}, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).finalizeAttachment(requestParameters.xApitoken, requestParameters.finalizeAttachmentRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create Form
     * @param {DefaultApiFormsCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public formsCreate(requestParameters: DefaultApiFormsCreateRequest = {}, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).formsCreate(requestParameters.accept, requestParameters.contentType, requestParameters.formsCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete Form
     * @param {DefaultApiFormsDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public formsDelete(requestParameters: DefaultApiFormsDeleteRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).formsDelete(requestParameters.formId, requestParameters.accept, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get All Forms
     * @param {DefaultApiFormsGetAllRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public formsGetAll(requestParameters: DefaultApiFormsGetAllRequest = {}, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).formsGetAll(requestParameters.schema, requestParameters.page, requestParameters.perPage, requestParameters.accept, requestParameters.type, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Form History
     * @param {DefaultApiFormsGetHistoryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public formsGetHistory(requestParameters: DefaultApiFormsGetHistoryRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).formsGetHistory(requestParameters.formId, requestParameters.version, requestParameters.page, requestParameters.perPage, requestParameters.accept, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Single Form
     * @param {DefaultApiFormsGetSingleRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public formsGetSingle(requestParameters: DefaultApiFormsGetSingleRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).formsGetSingle(requestParameters.formId, requestParameters.accept, requestParameters.schema, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update Form
     * @param {DefaultApiFormsUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public formsUpdate(requestParameters: DefaultApiFormsUpdateRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).formsUpdate(requestParameters.formId, requestParameters.accept, requestParameters.contentType, requestParameters.formsUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get All Attachments
     * @param {DefaultApiGetAllAttachmentsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getAllAttachments(requestParameters: DefaultApiGetAllAttachmentsRequest = {}, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getAllAttachments(requestParameters.recordId, requestParameters.formId, requestParameters.ownerType, requestParameters.xApitoken, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get All Batches
     * @param {DefaultApiGetAllBatchesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getAllBatches(requestParameters: DefaultApiGetAllBatchesRequest = {}, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getAllBatches(requestParameters.page, requestParameters.perPage, requestParameters.sort, requestParameters.sortDirection, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get All Groups
     * @param {DefaultApiGetAllGroupsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getAllGroups(requestParameters: DefaultApiGetAllGroupsRequest = {}, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getAllGroups(requestParameters.page, requestParameters.perPage, requestParameters.associations, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Membership Permissions
     * @param {DefaultApiGetAllMembershipsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getAllMemberships(requestParameters: DefaultApiGetAllMembershipsRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getAllMemberships(requestParameters.type, requestParameters.objectId, requestParameters.page, requestParameters.perPage, requestParameters.accept, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get All Report Templates
     * @param {DefaultApiGetAllReportTemplatesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getAllReportTemplates(requestParameters: DefaultApiGetAllReportTemplatesRequest = {}, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getAllReportTemplates(requestParameters.page, requestParameters.perPage, requestParameters.formId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get All Workflows
     * @param {DefaultApiGetAllWorkflowsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getAllWorkflows(requestParameters: DefaultApiGetAllWorkflowsRequest = {}, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getAllWorkflows(requestParameters.page, requestParameters.perPage, requestParameters.accept, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Group Resource
     * @param {DefaultApiGetGroupResourceRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getGroupResource(requestParameters: DefaultApiGetGroupResourceRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getGroupResource(requestParameters.groupId, requestParameters.resource, requestParameters.accept, requestParameters.page, requestParameters.perPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Single Attachment
     * @param {DefaultApiGetSingleAttachmentRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getSingleAttachment(requestParameters: DefaultApiGetSingleAttachmentRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getSingleAttachment(requestParameters.attachmentId, requestParameters.xApitoken, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Single Batch
     * @param {DefaultApiGetSingleBatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getSingleBatch(requestParameters: DefaultApiGetSingleBatchRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getSingleBatch(requestParameters.batchId, requestParameters.page, requestParameters.perPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Single Group
     * @param {DefaultApiGetSingleGroupRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getSingleGroup(requestParameters: DefaultApiGetSingleGroupRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getSingleGroup(requestParameters.groupId, requestParameters.accept, requestParameters.associations, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Single Report Template
     * @param {DefaultApiGetSingleReportTemplateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getSingleReportTemplate(requestParameters: DefaultApiGetSingleReportTemplateRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getSingleReportTemplate(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Single Workflow
     * @param {DefaultApiGetSingleWorkflowRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getSingleWorkflow(requestParameters: DefaultApiGetSingleWorkflowRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getSingleWorkflow(requestParameters.workflowId, requestParameters.accept, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create Layer
     * @param {DefaultApiLayersCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public layersCreate(requestParameters: DefaultApiLayersCreateRequest = {}, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).layersCreate(requestParameters.accept, requestParameters.contentType, requestParameters.layersCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete Layer
     * @param {DefaultApiLayersDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public layersDelete(requestParameters: DefaultApiLayersDeleteRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).layersDelete(requestParameters.layerId, requestParameters.accept, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get All Layers
     * @param {DefaultApiLayersGetAllRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public layersGetAll(requestParameters: DefaultApiLayersGetAllRequest = {}, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).layersGetAll(requestParameters.page, requestParameters.perPage, requestParameters.accept, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Single Layer
     * @param {DefaultApiLayersGetSingleRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public layersGetSingle(requestParameters: DefaultApiLayersGetSingleRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).layersGetSingle(requestParameters.layerId, requestParameters.accept, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update Layer
     * @param {DefaultApiLayersUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public layersUpdate(requestParameters: DefaultApiLayersUpdateRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).layersUpdate(requestParameters.layerId, requestParameters.accept, requestParameters.contentType, requestParameters.layersUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Add or remove membership permissions from layers, forms, or projects
     * @summary Change Permissions
     * @param {DefaultApiMembershipsChangePermissionsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public membershipsChangePermissions(requestParameters: DefaultApiMembershipsChangePermissionsRequest = {}, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).membershipsChangePermissions(requestParameters.accept, requestParameters.contentType, requestParameters.membershipsChangePermissionsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get All Memberships
     * @param {DefaultApiMembershipsGetAllRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public membershipsGetAll(requestParameters: DefaultApiMembershipsGetAllRequest = {}, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).membershipsGetAll(requestParameters.formId, requestParameters.projectId, requestParameters.layerId, requestParameters.page, requestParameters.perPage, requestParameters.accept, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Single Membership
     * @param {DefaultApiMembershipsGetSingleRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public membershipsGetSingle(requestParameters: DefaultApiMembershipsGetSingleRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).membershipsGetSingle(requestParameters.membershipId, requestParameters.accept, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get All Photos
     * @param {DefaultApiPhotosGetAllMetadataRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public photosGetAllMetadata(requestParameters: DefaultApiPhotosGetAllMetadataRequest = {}, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).photosGetAllMetadata(requestParameters.recordId, requestParameters.formId, requestParameters.newestFirst, requestParameters.processed, requestParameters.stored, requestParameters.uploaded, requestParameters.page, requestParameters.perPage, requestParameters.accept, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Single Photo File
     * @param {DefaultApiPhotosGetSingleFileRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public photosGetSingleFile(requestParameters: DefaultApiPhotosGetSingleFileRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).photosGetSingleFile(requestParameters.photoId, requestParameters.accept, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Single Photo Metadata
     * @param {DefaultApiPhotosGetSingleMetadataRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public photosGetSingleMetadata(requestParameters: DefaultApiPhotosGetSingleMetadataRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).photosGetSingleMetadata(requestParameters.photoId, requestParameters.accept, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Photo Large File
     * @param {DefaultApiPhotosLargeFileRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public photosLargeFile(requestParameters: DefaultApiPhotosLargeFileRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).photosLargeFile(requestParameters.photoId, requestParameters.accept, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Photo Large Metadata
     * @param {DefaultApiPhotosLargeMetadataRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public photosLargeMetadata(requestParameters: DefaultApiPhotosLargeMetadataRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).photosLargeMetadata(requestParameters.photoId, requestParameters.accept, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Photo Thumbnail File
     * @param {DefaultApiPhotosThumbnailFileRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public photosThumbnailFile(requestParameters: DefaultApiPhotosThumbnailFileRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).photosThumbnailFile(requestParameters.photoId, requestParameters.accept, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Photo Thumbnail Metadata
     * @param {DefaultApiPhotosThumbnailMetadataRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public photosThumbnailMetadata(requestParameters: DefaultApiPhotosThumbnailMetadataRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).photosThumbnailMetadata(requestParameters.photoId, requestParameters.accept, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Upload Photo
     * @param {DefaultApiPhotosUploadRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public photosUpload(requestParameters: DefaultApiPhotosUploadRequest = {}, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).photosUpload(requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create Project
     * @param {DefaultApiProjectsCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public projectsCreate(requestParameters: DefaultApiProjectsCreateRequest = {}, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).projectsCreate(requestParameters.accept, requestParameters.contentType, requestParameters.projectsCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete Project
     * @param {DefaultApiProjectsDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public projectsDelete(requestParameters: DefaultApiProjectsDeleteRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).projectsDelete(requestParameters.projectId, requestParameters.accept, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get All Projects
     * @param {DefaultApiProjectsGetAllRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public projectsGetAll(requestParameters: DefaultApiProjectsGetAllRequest = {}, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).projectsGetAll(requestParameters.page, requestParameters.perPage, requestParameters.accept, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Single Project
     * @param {DefaultApiProjectsGetSingleRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public projectsGetSingle(requestParameters: DefaultApiProjectsGetSingleRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).projectsGetSingle(requestParameters.projectId, requestParameters.accept, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update Project
     * @param {DefaultApiProjectsUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public projectsUpdate(requestParameters: DefaultApiProjectsUpdateRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).projectsUpdate(requestParameters.projectId, requestParameters.accept, requestParameters.contentType, requestParameters.projectsUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary GET Query
     * @param {DefaultApiQueryGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public queryGet(requestParameters: DefaultApiQueryGetRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).queryGet(requestParameters.q, requestParameters.format, requestParameters.headers, requestParameters.metadata, requestParameters.arrays, requestParameters.tableName, requestParameters.sortColumn, requestParameters.sortDirection, requestParameters.page, requestParameters.perPage, requestParameters.accept, requestParameters.userAgent, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary POST Query
     * @param {DefaultApiQueryPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public queryPost(requestParameters: DefaultApiQueryPostRequest = {}, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).queryPost(requestParameters.page, requestParameters.perPage, requestParameters.accept, requestParameters.queryPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create Record
     * @param {DefaultApiRecordsCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public recordsCreate(requestParameters: DefaultApiRecordsCreateRequest = {}, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).recordsCreate(requestParameters.accept, requestParameters.contentType, requestParameters.xSkipWorkflows, requestParameters.xSkipWebhooks, requestParameters.recordsCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete Record
     * @param {DefaultApiRecordsDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public recordsDelete(requestParameters: DefaultApiRecordsDeleteRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).recordsDelete(requestParameters.recordId, requestParameters.accept, requestParameters.xSkipWorkflows, requestParameters.xSkipWebhooks, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get All Records
     * @param {DefaultApiRecordsGetAllRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public recordsGetAll(requestParameters: DefaultApiRecordsGetAllRequest = {}, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).recordsGetAll(requestParameters.newestFirst, requestParameters.boundingBox, requestParameters.changesetId, requestParameters.formId, requestParameters.projectId, requestParameters.clientCreatedBefore, requestParameters.clientCreatedSince, requestParameters.clientUpdatedBefore, requestParameters.clientUpdatedSince, requestParameters.createdBefore, requestParameters.createdSince, requestParameters.updatedBefore, requestParameters.updatedSince, requestParameters.page, requestParameters.perPage, requestParameters.accept, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint can help you get records from a specific changeset, or retrieve records for a deleted form.
     * @summary Get All Records History
     * @param {DefaultApiRecordsGetAllHistoryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public recordsGetAllHistory(requestParameters: DefaultApiRecordsGetAllHistoryRequest = {}, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).recordsGetAllHistory(requestParameters.accept, requestParameters.changesetId, requestParameters.deletedFormId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Record History
     * @param {DefaultApiRecordsGetHistoryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public recordsGetHistory(requestParameters: DefaultApiRecordsGetHistoryRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).recordsGetHistory(requestParameters.recordId, requestParameters.accept, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Single Record
     * @param {DefaultApiRecordsGetSingleRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public recordsGetSingle(requestParameters: DefaultApiRecordsGetSingleRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).recordsGetSingle(requestParameters.recordId, requestParameters.accept, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update Record
     * @param {DefaultApiRecordsUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public recordsUpdate(requestParameters: DefaultApiRecordsUpdateRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).recordsUpdate(requestParameters.recordId, requestParameters.accept, requestParameters.contentType, requestParameters.xSkipWorkflows, requestParameters.xSkipWebhooks, requestParameters.recordsUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get All Roles
     * @param {DefaultApiRolesGetAllRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public rolesGetAll(requestParameters: DefaultApiRolesGetAllRequest = {}, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).rolesGetAll(requestParameters.page, requestParameters.perPage, requestParameters.accept, requestParameters.sort, requestParameters.sortDirection, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get All Signatures
     * @param {DefaultApiSignaturesGetAllRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public signaturesGetAll(requestParameters: DefaultApiSignaturesGetAllRequest = {}, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).signaturesGetAll(requestParameters.recordId, requestParameters.formId, requestParameters.newestFirst, requestParameters.processed, requestParameters.stored, requestParameters.uploaded, requestParameters.page, requestParameters.perPage, requestParameters.accept, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Single Signature File
     * @param {DefaultApiSignaturesGetSingleFileRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public signaturesGetSingleFile(requestParameters: DefaultApiSignaturesGetSingleFileRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).signaturesGetSingleFile(requestParameters.signatureId, requestParameters.accept, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Single Signature Metadata
     * @param {DefaultApiSignaturesGetSingleMetadataRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public signaturesGetSingleMetadata(requestParameters: DefaultApiSignaturesGetSingleMetadataRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).signaturesGetSingleMetadata(requestParameters.signatureId, requestParameters.accept, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Signature Thumbnail File
     * @param {DefaultApiSignaturesGetThumbnailFileRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public signaturesGetThumbnailFile(requestParameters: DefaultApiSignaturesGetThumbnailFileRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).signaturesGetThumbnailFile(requestParameters.signatureId, requestParameters.accept, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Signature Thumbnail Metadata
     * @param {DefaultApiSignaturesGetThumbnailMetadataRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public signaturesGetThumbnailMetadata(requestParameters: DefaultApiSignaturesGetThumbnailMetadataRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).signaturesGetThumbnailMetadata(requestParameters.signatureId, requestParameters.accept, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Upload Signature
     * @param {DefaultApiSignaturesUploadRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public signaturesUpload(requestParameters: DefaultApiSignaturesUploadRequest = {}, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).signaturesUpload(requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Start your pending batch
     * @summary Start Batch
     * @param {DefaultApiStartBatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public startBatch(requestParameters: DefaultApiStartBatchRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).startBatch(requestParameters.batchId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update Group Name / Description
     * @param {DefaultApiUpdateGroupNameDescriptionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updateGroupNameDescription(requestParameters: DefaultApiUpdateGroupNameDescriptionRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).updateGroupNameDescription(requestParameters.groupId, requestParameters.accept, requestParameters.contentType, requestParameters.updateGroupNameDescriptionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update Group Permissions
     * @param {DefaultApiUpdateGroupPermissionsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updateGroupPermissions(requestParameters: DefaultApiUpdateGroupPermissionsRequest = {}, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).updateGroupPermissions(requestParameters.accept, requestParameters.contentType, requestParameters.updateGroupPermissionsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * You can use this to update parameters of a member, but this will not work if the member is apart of multiple organizations.
     * @summary Update Member
     * @param {DefaultApiUpdateMemberRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updateMember(requestParameters: DefaultApiUpdateMemberRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).updateMember(requestParameters.membershipId, requestParameters.updateMemberRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update Report Template
     * @param {DefaultApiUpdateReportTemplateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updateReportTemplate(requestParameters: DefaultApiUpdateReportTemplateRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).updateReportTemplate(requestParameters.id, requestParameters.updateReportTemplateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update Workflow
     * @param {DefaultApiUpdateWorkflowRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updateWorkflow(requestParameters: DefaultApiUpdateWorkflowRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).updateWorkflow(requestParameters.workflowId, requestParameters.accept, requestParameters.contentTyoe, requestParameters.updateWorkflowRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get User Information
     * @param {DefaultApiUsersGetUserRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public usersGetUser(requestParameters: DefaultApiUsersGetUserRequest = {}, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).usersGetUser(requestParameters.page, requestParameters.perPage, requestParameters.accept, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get All Videos
     * @param {DefaultApiVideosGetAllRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public videosGetAll(requestParameters: DefaultApiVideosGetAllRequest = {}, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).videosGetAll(requestParameters.recordId, requestParameters.formId, requestParameters.newestFirst, requestParameters.processed, requestParameters.stored, requestParameters.uploaded, requestParameters.page, requestParameters.perPage, requestParameters.accept, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get GeoJSON Tracks for All Videos
     * @param {DefaultApiVideosGetAllTracksGeojsonRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public videosGetAllTracksGeojson(requestParameters: DefaultApiVideosGetAllTracksGeojsonRequest = {}, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).videosGetAllTracksGeojson(requestParameters.accept, requestParameters.type, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get GPX Tracks for All Videos
     * @param {DefaultApiVideosGetAllTracksGpxRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public videosGetAllTracksGpx(requestParameters: DefaultApiVideosGetAllTracksGpxRequest = {}, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).videosGetAllTracksGpx(requestParameters.accept, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get KML Tracks for All Videos
     * @param {DefaultApiVideosGetAllTracksKmlRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public videosGetAllTracksKml(requestParameters: DefaultApiVideosGetAllTracksKmlRequest = {}, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).videosGetAllTracksKml(requestParameters.accept, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Medium Video File
     * @param {DefaultApiVideosGetMediumFileRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public videosGetMediumFile(requestParameters: DefaultApiVideosGetMediumFileRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).videosGetMediumFile(requestParameters.videoId, requestParameters.accept, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Original Video File
     * @param {DefaultApiVideosGetOriginalFileRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public videosGetOriginalFile(requestParameters: DefaultApiVideosGetOriginalFileRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).videosGetOriginalFile(requestParameters.videoId, requestParameters.accept, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Video Metadata
     * @param {DefaultApiVideosGetSingleMetadataRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public videosGetSingleMetadata(requestParameters: DefaultApiVideosGetSingleMetadataRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).videosGetSingleMetadata(requestParameters.videoId, requestParameters.accept, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get GeoJSON Video Track
     * @param {DefaultApiVideosGetSingleTrackGeojsonRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public videosGetSingleTrackGeojson(requestParameters: DefaultApiVideosGetSingleTrackGeojsonRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).videosGetSingleTrackGeojson(requestParameters.videoId, requestParameters.accept, requestParameters.type, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get GPX Video Track
     * @param {DefaultApiVideosGetSingleTrackGpxRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public videosGetSingleTrackGpx(requestParameters: DefaultApiVideosGetSingleTrackGpxRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).videosGetSingleTrackGpx(requestParameters.videoId, requestParameters.accept, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get JSON Video Track
     * @param {DefaultApiVideosGetSingleTrackJsonRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public videosGetSingleTrackJson(requestParameters: DefaultApiVideosGetSingleTrackJsonRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).videosGetSingleTrackJson(requestParameters.videoId, requestParameters.accept, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get KML Video Track
     * @param {DefaultApiVideosGetSingleTrackKmlRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public videosGetSingleTrackKml(requestParameters: DefaultApiVideosGetSingleTrackKmlRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).videosGetSingleTrackKml(requestParameters.videoId, requestParameters.accept, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Small Video File
     * @param {DefaultApiVideosGetSmallFileRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public videosGetSmallFile(requestParameters: DefaultApiVideosGetSmallFileRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).videosGetSmallFile(requestParameters.videoId, requestParameters.accept, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Huge Video Thumbnail
     * @param {DefaultApiVideosGetThumbnailHugeRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public videosGetThumbnailHuge(requestParameters: DefaultApiVideosGetThumbnailHugeRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).videosGetThumbnailHuge(requestParameters.videoId, requestParameters.accept, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Huge Square Video Thumbnail
     * @param {DefaultApiVideosGetThumbnailHugeSquareRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public videosGetThumbnailHugeSquare(requestParameters: DefaultApiVideosGetThumbnailHugeSquareRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).videosGetThumbnailHugeSquare(requestParameters.videoId, requestParameters.accept, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Large Video Thumbnail
     * @param {DefaultApiVideosGetThumbnailLargeRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public videosGetThumbnailLarge(requestParameters: DefaultApiVideosGetThumbnailLargeRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).videosGetThumbnailLarge(requestParameters.videoId, requestParameters.accept, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Large Square Video Thumbnail
     * @param {DefaultApiVideosGetThumbnailLargeSquareRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public videosGetThumbnailLargeSquare(requestParameters: DefaultApiVideosGetThumbnailLargeSquareRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).videosGetThumbnailLargeSquare(requestParameters.videoId, requestParameters.accept, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Medium Video Thumbnail
     * @param {DefaultApiVideosGetThumbnailMediumRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public videosGetThumbnailMedium(requestParameters: DefaultApiVideosGetThumbnailMediumRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).videosGetThumbnailMedium(requestParameters.videoId, requestParameters.accept, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Medium Square Video Thumbnail
     * @param {DefaultApiVideosGetThumbnailMediumSquareRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public videosGetThumbnailMediumSquare(requestParameters: DefaultApiVideosGetThumbnailMediumSquareRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).videosGetThumbnailMediumSquare(requestParameters.videoId, requestParameters.accept, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Small Video Thumbnail
     * @param {DefaultApiVideosGetThumbnailSmallRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public videosGetThumbnailSmall(requestParameters: DefaultApiVideosGetThumbnailSmallRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).videosGetThumbnailSmall(requestParameters.videoId, requestParameters.accept, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Small Square Video Thumbnail
     * @param {DefaultApiVideosGetThumbnailSmallSquareRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public videosGetThumbnailSmallSquare(requestParameters: DefaultApiVideosGetThumbnailSmallSquareRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).videosGetThumbnailSmallSquare(requestParameters.videoId, requestParameters.accept, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Upload video with optional track file
     * @summary Upload Video
     * @param {DefaultApiVideosUploadRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public videosUpload(requestParameters: DefaultApiVideosUploadRequest = {}, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).videosUpload(requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create Webhook
     * @param {DefaultApiWebhooksCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public webhooksCreate(requestParameters: DefaultApiWebhooksCreateRequest = {}, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).webhooksCreate(requestParameters.accept, requestParameters.contentType, requestParameters.webhooksCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete Webhook
     * @param {DefaultApiWebhooksDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public webhooksDelete(requestParameters: DefaultApiWebhooksDeleteRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).webhooksDelete(requestParameters.webhookId, requestParameters.accept, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get All Webhooks
     * @param {DefaultApiWebhooksGetAllRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public webhooksGetAll(requestParameters: DefaultApiWebhooksGetAllRequest = {}, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).webhooksGetAll(requestParameters.page, requestParameters.perPage, requestParameters.accept, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Single Webhook
     * @param {DefaultApiWebhooksGetSingleRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public webhooksGetSingle(requestParameters: DefaultApiWebhooksGetSingleRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).webhooksGetSingle(requestParameters.webhookId, requestParameters.accept, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update Webhook
     * @param {DefaultApiWebhooksUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public webhooksUpdate(requestParameters: DefaultApiWebhooksUpdateRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).webhooksUpdate(requestParameters.webhookId, requestParameters.accept, requestParameters.contentType, requestParameters.webhooksUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }
}

export enum ClassificationSetsGetAllTypeEnum {
    Organization = 'organization',
    System = 'system',
    All = 'all'
}
export enum FormsGetAllTypeEnum {
    Organization = 'organization',
    System = 'system',
    All = 'all'
}
