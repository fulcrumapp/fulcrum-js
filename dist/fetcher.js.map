{"version":3,"sources":["../src/fetcher.js"],"names":["getQueryString","params","Object","keys","map","encodeURIComponent","k","join","errorMessageForStatus","status","messages","Fetcher","options","headers","opts","forEach","key","baseURI","hasOwnProperty","body","JSON","stringify","url","fetch","resp","ok","errorMessage","Error","contentType","get","split","json","text","path","qs","_processOptions","assign","method","_fetch"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,SAASA,cAAT,CAAwBC,MAAxB,EAAgC;AAC9B,SAAOC,OAAOC,IAAP,CAAYF,MAAZ,EACJG,GADI,CACA;AAAA,WAAKC,mBAAmBC,CAAnB,IAAwB,GAAxB,GAA8BD,mBAAmBJ,OAAOK,CAAP,CAAnB,CAAnC;AAAA,GADA,EAEJC,IAFI,CAEC,GAFD,CAAP;AAGD;;AAED,SAASC,qBAAT,CAA+BC,MAA/B,EAAuC;AACrC,MAAMC,WAAW;AACf,SAAK,aADU;AAEf,SAAK,cAFU;AAGf,SAAK,kBAHU;AAIf,SAAK,WAJU;AAKf,SAAK;AALU,GAAjB;;AAQA,SAAOA,SAASD,MAAT,eAA4BA,MAAnC;AACD;;IAEoBE,O;AACnB,mBAAYC,OAAZ,EAAqB;AAAA;;AACnB,SAAKA,OAAL,GAAeA,OAAf;;AAEA,SAAKC,OAAL,GAAeD,QAAQC,OAAvB;AACD;;;;oCAEeC,I,EAAM;AACpB,UAAMF,qCACDE,IADC;AAEJD,4CACK,KAAKA,OADV,EAEKC,KAAKD,OAFV;AAFI,QAAN;;AAQA;AACA;AACAX,aAAOC,IAAP,CAAYS,QAAQC,OAApB,EAA6BE,OAA7B,CAAqC,eAAO;AAC1C,YAAI,OAAOH,QAAQC,OAAR,CAAgBG,GAAhB,CAAP,KAAgC,WAAhC,IACAJ,QAAQC,OAAR,CAAgBG,GAAhB,MAAyB,IADzB,IAEAJ,QAAQC,OAAR,CAAgBG,GAAhB,MAAyB,EAF7B,EAEiC;AAC/B,iBAAOJ,QAAQC,OAAR,CAAgBG,GAAhB,CAAP;AACD;AACF,OAND;;AAQA,aAAOJ,QAAQK,OAAf;;AAEA,UAAIL,WAAWA,QAAQM,cAAR,CAAuB,MAAvB,CAAX,IACAN,QAAQM,cAAR,CAAuB,SAAvB,CADA,IACqCN,QAAQC,OAAR,CAAgB,cAAhB,MAAoC,kBAD7E,EACiG;AAC/FD,gBAAQO,IAAR,GAAeC,KAAKC,SAAL,CAAeT,QAAQO,IAAvB,CAAf;AACD;;AAED,aAAOP,OAAP;AACD;;;;2GAEYU,G,EAAKV,O;;;;;;;uBACGW,MAAMD,GAAN,EAAWV,OAAX,C;;;AAAbY,oB;;oBAEDA,KAAKC,E;;;;;AACFC,4B,GAAelB,sBAAsBgB,KAAKf,MAA3B,KAAsC,e;sBACrD,IAAIkB,KAAJ,CAAUD,YAAV,C;;;AAGFE,2B,GAAcJ,KAAKX,OAAL,CAAagB,GAAb,CAAiB,cAAjB,C;;sBAChBD,eAAeA,YAAYE,KAAZ,CAAkB,GAAlB,EAAuB,CAAvB,MAA8B,kB;;;;;iDACxCN,KAAKO,IAAL,E;;;iDAGFP,KAAKQ,IAAL,E;;;;;;;;;;;;;;;;;;wBAGLC,I,EAAMnB,I,EAAM;AACd,UAAIQ,MAAM,KAAKV,OAAL,CAAaK,OAAb,GAAuB,GAAvB,GAA6BgB,IAAvC;;AAEA,UAAInB,QAAQA,KAAKI,cAAL,CAAoB,IAApB,CAAZ,EAAuC;AACrCI,eAAO,MAAMtB,eAAec,KAAKoB,EAApB,CAAb;AACA,eAAOpB,KAAKoB,EAAZ;AACD;;AAED,UAAMtB,UAAU,KAAKuB,eAAL,CAAqBjC,OAAOkC,MAAP,CAAc,EAACC,QAAQ,KAAT,EAAd,EAA+BvB,IAA/B,CAArB,CAAhB;;AAEA,aAAO,KAAKwB,MAAL,CAAYhB,GAAZ,EAAiBV,OAAjB,CAAP;AACD;;;yBAEIqB,I,EAAMnB,I,EAAM;AACf,UAAMQ,MAAM,KAAKV,OAAL,CAAaK,OAAb,GAAuB,GAAvB,GAA6BgB,IAAzC;;AAEA,UAAMrB,UAAU,KAAKuB,eAAL,CAAqBjC,OAAOkC,MAAP,CAAc,EAACC,QAAQ,MAAT,EAAd,EAAgCvB,IAAhC,CAArB,CAAhB;;AAEA,aAAO,KAAKwB,MAAL,CAAYhB,GAAZ,EAAiBV,OAAjB,CAAP;AACD;;;wBAEGqB,I,EAAMnB,I,EAAM;AACd,UAAMQ,MAAM,KAAKV,OAAL,CAAaK,OAAb,GAAuB,GAAvB,GAA6BgB,IAAzC;;AAEA,UAAMrB,UAAU,KAAKuB,eAAL,CAAqBjC,OAAOkC,MAAP,CAAc,EAACC,QAAQ,KAAT,EAAd,EAA+BvB,IAA/B,CAArB,CAAhB;;AAEA,aAAO,KAAKwB,MAAL,CAAYhB,GAAZ,EAAiBV,OAAjB,CAAP;AACD;;;wBAEGqB,I,EAAMnB,I,EAAM;AACd,UAAMQ,MAAM,KAAKV,OAAL,CAAaK,OAAb,GAAuB,GAAvB,GAA6BgB,IAAzC;;AAEA,UAAMrB,UAAU,KAAKuB,eAAL,CAAqBjC,OAAOkC,MAAP,CAAc,EAACC,QAAQ,QAAT,EAAd,EAAkCvB,IAAlC,CAArB,CAAhB;;AAEA,aAAO,KAAKwB,MAAL,CAAYhB,GAAZ,EAAiBV,OAAjB,CAAP;AACD;;;;;kBAvFkBD,O","file":"fetcher.js","sourcesContent":["function getQueryString(params) {\n  return Object.keys(params)\n    .map(k => encodeURIComponent(k) + '=' + encodeURIComponent(params[k]))\n    .join('&');\n}\n\nfunction errorMessageForStatus(status) {\n  const messages = {\n    400: 'Bad Request',\n    401: 'Unauthorized',\n    402: 'Payment Required',\n    403: 'Forbidden',\n    404: 'Not Found'\n  };\n\n  return messages[status] || `HTTP ${status}`;\n}\n\nexport default class Fetcher {\n  constructor(options) {\n    this.options = options;\n\n    this.headers = options.headers;\n  }\n\n  _processOptions(opts) {\n    const options = {\n      ...opts,\n      headers: {\n        ...this.headers,\n        ...opts.headers\n      }\n    };\n\n    // remove any nil or blank headers\n    // (e.g. to automatically set Content-Type with `FormData` boundary)\n    Object.keys(options.headers).forEach(key => {\n      if (typeof options.headers[key] === 'undefined' ||\n          options.headers[key] === null ||\n          options.headers[key] === '') {\n        delete options.headers[key];\n      }\n    });\n\n    delete options.baseURI;\n\n    if (options && options.hasOwnProperty('body') &&\n        options.hasOwnProperty('headers') && options.headers['Content-Type'] === 'application/json') {\n      options.body = JSON.stringify(options.body);\n    }\n\n    return options;\n  }\n\n  async _fetch(url, options) {\n    const resp = await fetch(url, options);\n\n    if (!resp.ok) {\n      const errorMessage = errorMessageForStatus(resp.status) || 'Unknown Error';\n      throw new Error(errorMessage);\n    }\n\n    const contentType = resp.headers.get('Content-Type');\n    if (contentType && contentType.split(';')[0] === 'application/json') {\n      return resp.json();\n    }\n\n    return resp.text();\n  }\n\n  get(path, opts) {\n    let url = this.options.baseURI + '/' + path;\n\n    if (opts && opts.hasOwnProperty('qs')) {\n      url += '?' + getQueryString(opts.qs);\n      delete opts.qs;\n    }\n\n    const options = this._processOptions(Object.assign({method: 'GET'}, opts));\n\n    return this._fetch(url, options);\n  }\n\n  post(path, opts) {\n    const url = this.options.baseURI + '/' + path;\n\n    const options = this._processOptions(Object.assign({method: 'POST'}, opts));\n\n    return this._fetch(url, options);\n  }\n\n  put(path, opts) {\n    const url = this.options.baseURI + '/' + path;\n\n    const options = this._processOptions(Object.assign({method: 'PUT'}, opts));\n\n    return this._fetch(url, options);\n  }\n\n  del(path, opts) {\n    const url = this.options.baseURI + '/' + path;\n\n    const options = this._processOptions(Object.assign({method: 'DELETE'}, opts));\n\n    return this._fetch(url, options);\n  }\n}\n"]}